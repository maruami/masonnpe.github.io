<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Masonnpe&#39;s Blog</title>
  
  <subtitle>愿所有的坚持终不被辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://masonnpe.github.io/"/>
  <updated>2018-11-03T11:42:57.818Z</updated>
  <id>https://masonnpe.github.io/</id>
  
  <author>
    <name>Masonnpe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Collections.sort()解读</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/Collections.sort()%E8%A7%A3%E8%AF%BB/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/Collections.sort()解读/</id>
    <published>2018-11-03T11:41:48.451Z</published>
    <updated>2018-11-03T11:42:57.818Z</updated>
    
    <content type="html"><![CDATA[<p>Collections.sort方法底层就是调用的Array.sort</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// array的大小为0或者1就不用排了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数组大小小于MIN_MERGE(32)的时候，就用一个"mini-TimSort"的方法排序</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="comment">// 将最长的递减序列，找出来，然后倒过来</span></span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            <span class="comment">// 长度小于32的时候，是使用binarySort的</span></span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先扫描一次array，找到已经排好的序列，然后再用刚才的mini-TimSort，然后合并</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Identify next run</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Collections.sort方法底层就是调用的Array.sort&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T[] a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; lo, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hi, Comparator&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; c,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                         T[] work, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; workBase, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; workLen)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; c != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; a != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lo &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; lo &amp;lt;= hi &amp;amp;&amp;amp; hi &amp;lt;= a.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nRemaining  = hi - lo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nRemaining &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// array的大小为0或者1就不用排了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 当数组大小小于MIN_MERGE(32)的时候，就用一个&quot;mini-TimSort&quot;的方法排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nRemaining &amp;lt; MIN_MERGE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 将最长的递减序列，找出来，然后倒过来&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initRunLen = countRunAndMakeAscending(a, lo, hi, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 长度小于32的时候，是使用binarySort的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            binarySort(a, lo, hi, lo + initRunLen, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 先扫描一次array，找到已经排好的序列，然后再用刚才的mini-TimSort，然后合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TimSort&amp;lt;T&amp;gt; ts = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TimSort&amp;lt;&amp;gt;(a, c, work, workBase, workLen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minRun = minRunLength(nRemaining);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Identify next run&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; runLen = countRunAndMakeAscending(a, lo, hi, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// If run is short, extend to min(minRun, nRemaining)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (runLen &amp;lt; minRun) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; force = nRemaining &amp;lt;= minRun ? nRemaining : minRun;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                binarySort(a, lo, lo + force, lo + runLen, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                runLen = force;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Push run onto pending-run stack, and maybe merge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ts.pushRun(lo, runLen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ts.mergeCollapse();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Advance to find next run&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lo += runLen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nRemaining -= runLen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (nRemaining != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Merge all remaining runs to complete sort&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; lo == hi;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ts.mergeForceCollapse();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; ts.stackSize == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Collections" scheme="https://masonnpe.github.io/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>ApplicationContext</title>
    <link href="https://masonnpe.github.io/2018/11/03/Spring/ApplicationContext/"/>
    <id>https://masonnpe.github.io/2018/11/03/Spring/ApplicationContext/</id>
    <published>2018-11-03T11:02:33.905Z</published>
    <updated>2018-11-03T11:05:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>applicationcontext和beanfactory都是加载bean的</p><p>applicationcontext包含beanfactory的所有功能，是对beanfactory的扩展。   添加了@Qualifier  @Autowired等功能</p><p>beanfactory适合内存小的</p><a id="more"></a><p>实例化bean比较复杂，FactoryBean是一个工厂类接口，可以通过改接口实例化bean的逻辑</p><p>spring中的循环依赖分三种</p><ul><li><p>构造器循环依赖     无法解决 只能跑出beancurrentlyincreateionexception</p></li><li><p>setter注入  通过提前暴露单例工厂方法addSingletionFactory</p></li><li><p>protootype,spring无法完成依赖注入</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;applicationcontext和beanfactory都是加载bean的&lt;/p&gt;
&lt;p&gt;applicationcontext包含beanfactory的所有功能，是对beanfactory的扩展。   添加了@Qualifier  @Autowired等功能&lt;/p&gt;
&lt;p&gt;beanfactory适合内存小的&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://masonnpe.github.io/categories/Spring/"/>
    
    
      <category term="ApplicationContext" scheme="https://masonnpe.github.io/tags/ApplicationContext/"/>
    
  </entry>
  
  <entry>
    <title>001两数之和</title>
    <link href="https://masonnpe.github.io/2018/11/03/LeetCode/001%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20/"/>
    <id>https://masonnpe.github.io/2018/11/03/LeetCode/001两数之和 /</id>
    <published>2018-11-03T11:01:57.500Z</published>
    <updated>2018-11-03T11:39:15.778Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[j]==target-nums[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Solution solution=<span class="keyword">new</span> Solution();</span><br><span class="line"><span class="keyword">int</span>[] nums= &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> target=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] data= solution.twoSum(nums, target);</span><br><span class="line">System.out.println(Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> key=target-nums[i];</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(key)&amp;&amp;map.get(key)!=i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(key)&#125;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Solution solution=<span class="keyword">new</span> Solution();</span><br><span class="line"><span class="keyword">int</span>[] nums= &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> target=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] data= solution.twoSum(nums, target);</span><br><span class="line">System.out.println(Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">int key=target-nums[i];</span><br><span class="line">if(map.containsKey(key)&amp;&amp;map.get(key)!=i) &#123;</span><br><span class="line">return new int[] &#123;map.get(key),i&#125;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Solution solution=new Solution();</span><br><span class="line">int[] nums= &#123;2, 7, 11, 15&#125;;</span><br><span class="line">int target=9;</span><br><span class="line">int[] data= solution.twoSum(nums, target);</span><br><span class="line">System.out.println(Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：检查数组中是否存在目标元素，返回下标，保持数组中的每个元素与其索引相互对应的最好方法是哈希表</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nums[j]==target-nums[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] &amp;#123;i,j&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;No two sum solution&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Solution solution=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Solution();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums= &amp;#123;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] data= solution.twoSum(nums, target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(Arrays.toString(data));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://masonnpe.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/Queue/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/Queue/</id>
    <published>2018-11-03T11:01:15.136Z</published>
    <updated>2018-11-03T11:20:12.011Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>method</th><th>description</th></tr></thead><tbody><tr><td>add</td><td>添加元素  如果队列满 抛出异常</td></tr><tr><td>offer</td><td>元素插入到队尾 如果队列满，返回false</td></tr><tr><td>put</td><td>添加元素 队列满则阻塞</td></tr><tr><td>peek</td><td>不移除元素返回队头，队列为空返回null</td></tr><tr><td>element</td><td>不移除元素返回队头，队列为空抛异常</td></tr><tr><td>poll</td><td>移除元素返回队头，队列为空返回null</td></tr><tr><td>remove</td><td>移除元素返回队头，队列为空抛异常</td></tr><tr><td>take</td><td>移除并返回队头，队列空则阻塞</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;添加元素  如果队列满 抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Queue" scheme="https://masonnpe.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/%E6%95%B0%E7%BB%84/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/数组/</id>
    <published>2018-11-03T11:00:31.114Z</published>
    <updated>2018-11-03T11:30:17.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] arr2= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr3= <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><table><thead><tr><th>method</th><th>description</th></tr></thead><tbody><tr><td>Arrays.fill(arr, val);</td><td>替换数组的值</td></tr><tr><td>Arrays.fill(arr, fromIndex, toIndex, val);</td><td>替换数组下标<strong>[fromIndex,toIndex)</strong>的值</td></tr><tr><td>Arrays.copyOf(arr, newLength);</td><td>拷贝数组，先数组长度为newLength</td></tr><tr><td>Arrays.copyOfRange(arr, from, to);</td><td>拷贝数组下标<strong>[from,to)</strong>的值</td></tr><tr><td>Arrays.toString(arr);</td><td>打印数组</td></tr><tr><td>Arrays.binarySearch(arr, val);</td><td>二分查找，返回下标</td></tr><tr><td>System.arraycopy(src, srcPos, dest, destPos, length);</td><td>src原数组，srcPos起始index，dest目标数组，despos起始位置，length拷贝长度，属于浅拷贝</td></tr><tr><td>Arrays.sort(arr);</td><td>排序</td></tr><tr><td>Arrays.equals(arr1, arr2);</td><td>比较两个数据是否相等</td></tr></tbody></table><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组初始化&quot;&gt;&lt;a href=&quot;#数组初始化&quot; class=&quot;headerlink&quot; title=&quot;数组初始化&quot;&gt;&lt;/a&gt;数组初始化&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr1= &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr2= &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr3= &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Arrays&quot;&gt;&lt;a href=&quot;#Arrays&quot; class=&quot;headerlink&quot; title=&quot;Arrays&quot;&gt;&lt;/a&gt;Arrays&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.fill(arr, val);&lt;/td&gt;
&lt;td&gt;替换数组的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.fill(arr, fromIndex, toIndex, val);&lt;/td&gt;
&lt;td&gt;替换数组下标&lt;strong&gt;[fromIndex,toIndex)&lt;/strong&gt;的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.copyOf(arr, newLength);&lt;/td&gt;
&lt;td&gt;拷贝数组，先数组长度为newLength&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.copyOfRange(arr, from, to);&lt;/td&gt;
&lt;td&gt;拷贝数组下标&lt;strong&gt;[from,to)&lt;/strong&gt;的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.toString(arr);&lt;/td&gt;
&lt;td&gt;打印数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.binarySearch(arr, val);&lt;/td&gt;
&lt;td&gt;二分查找，返回下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;System.arraycopy(src, srcPos, dest, destPos, length);&lt;/td&gt;
&lt;td&gt;src原数组，srcPos起始index，dest目标数组，despos起始位置，length拷贝长度，属于浅拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.sort(arr);&lt;/td&gt;
&lt;td&gt;排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arrays.equals(arr1, arr2);&lt;/td&gt;
&lt;td&gt;比较两个数据是否相等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的JDBC</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/%E7%AE%80%E5%8D%95%E7%9A%84JDBC/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/简单的JDBC/</id>
    <published>2018-11-03T10:59:57.799Z</published>
    <updated>2018-11-03T11:30:22.544Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Conn &#123;</span><br><span class="line"></span><br><span class="line">static Connection connection;</span><br><span class="line">static Statement stat;</span><br><span class="line">static ResultSet rs;</span><br><span class="line"></span><br><span class="line">public Connection getConnection() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Connection conn=null;</span><br><span class="line">try &#123;</span><br><span class="line">conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mall&quot;, &quot;root&quot;, &quot;Gepoint&quot;);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Conn c=new Conn();</span><br><span class="line">connection=c.getConnection();</span><br><span class="line">try &#123;</span><br><span class="line">stat=connection.createStatement();</span><br><span class="line">rs=stat.executeQuery(&quot;select * from spbrands limit 10&quot;);</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">String brand=rs.getString(&quot;Brand&quot;);</span><br><span class="line">System.out.println(&quot;品牌:&quot;+brand);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Conn &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	static Connection connection;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	static Statement stat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	static ResultSet rs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Connection getConnection() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; catch (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Connection conn=null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			conn=DriverManager.getConnection(&amp;quot;jdbc:mysql://localhost:3306/mall&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;Gepoint&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; catch (SQLException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return conn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Conn c=new Conn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		connection=c.getConnection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stat=connection.createStatement();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			rs=stat.executeQuery(&amp;quot;select * from spbrands limit 10&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			while(rs.next()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				String brand=rs.getString(&amp;quot;Brand&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				System.out.println(&amp;quot;品牌:&amp;quot;+brand);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; catch (SQLException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedHashMap实现一个LRU本地缓存</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/LinkedHashMap%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/LinkedHashMap实现一个LRU本地缓存/</id>
    <published>2018-11-03T10:58:54.228Z</published>
    <updated>2018-11-03T11:16:20.225Z</updated>
    
    <content type="html"><![CDATA[<p>基于访问的最近最少使用算法</p><p>构造函数accessOrder=true时,当get（Object key）时，将最新访问的元素放到双向链表的第一位</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map&lt;String,String&gt; map=new LinkedHashMap&lt;&gt;(16,0.75f,true);</span><br><span class="line">map.put(&quot;brand1&quot;, &quot;12&quot;);</span><br><span class="line">map.put(&quot;brand2&quot;, &quot;13&quot;);</span><br><span class="line">map.put(&quot;brand3&quot;, &quot;14&quot;);</span><br><span class="line">map.put(&quot;brand4&quot;, &quot;15&quot;);</span><br><span class="line">map.put(&quot;brand5&quot;, &quot;16&quot;);</span><br><span class="line">map.put(&quot;brand6&quot;, &quot;17&quot;);</span><br><span class="line">print(map);</span><br><span class="line">map.get(&quot;brand2&quot;);</span><br><span class="line">print(map);</span><br><span class="line">map.get(&quot;brand5&quot;);</span><br><span class="line">print(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void print(Map&lt;String,String&gt; map) &#123;</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; set=map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; i=set.iterator();</span><br><span class="line">while(i.hasNext()) &#123;</span><br><span class="line">Entry&lt;String,String&gt; entry=i.next();</span><br><span class="line">System.out.println(entry.getValue()+entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;---&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于访问的最近最少使用算法&lt;/p&gt;
&lt;p&gt;构造函数accessOrder=true时,当get（Object key）时，将最新访问的元素放到双向链表的第一位&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="LinkedHashMap" scheme="https://masonnpe.github.io/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>String与StrinBuilder与StringBuffer</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/String%E4%B8%8EStrinBuilder%E4%B8%8EStringBuffer/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/String与StrinBuilder与StringBuffer/</id>
    <published>2018-11-03T10:58:13.276Z</published>
    <updated>2018-11-03T11:29:03.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String的创建机理"><a href="#String的创建机理" class="headerlink" title="String的创建机理"></a>String的创建机理</h3><p>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：</p><blockquote><p>创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。</p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"123"</span>; <span class="comment">//通过直接量赋值方式，放入字符串常量池</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(“<span class="number">123</span>”);<span class="comment">//通过new方式赋值方式，不放入字符串常量池</span></span><br></pre></td></tr></table></figure><p>注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。</p><p>Intern()是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。幸好在Oracle JDK 8u20之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，并不需<br>要Java类库做什么修改。注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用G1 GC：<br>-XX:+UseStringDeduplication</p><a id="more"></a><h3 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h3><ul><li><p>不可变。是指String对象一旦生成，则不能再对它进行改变。不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。</p></li><li><p>针对常量池的优化。当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。</p></li></ul><h2 id="StringBufer-StringBuilder"><a href="#StringBufer-StringBuilder" class="headerlink" title="StringBufer/StringBuilder"></a>StringBufer/StringBuilder</h2><p>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口；其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储，不同点是StringBufer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。<br>需要注意的是：<strong>StringBuffer是线程安全的，但是StringBuilder是线程不安全的，StringBuffer类中方法定义前面都会有synchronized关键字。为此，StringBuffer的性能要远低StringBuilder</strong></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。</li><li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBufer，例如XML解析、HTTP参数解析与封装。</li><li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;h3 id=&quot;String的创建机理&quot;&gt;&lt;a href=&quot;#String的创建机理&quot; class=&quot;headerlink&quot; title=&quot;String的创建机理&quot;&gt;&lt;/a&gt;String的创建机理&lt;/h3&gt;&lt;p&gt;由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String str1 = &lt;span class=&quot;string&quot;&gt;&quot;123&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//通过直接量赋值方式，放入字符串常量池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String str2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(“&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;”);&lt;span class=&quot;comment&quot;&gt;//通过new方式赋值方式，不放入字符串常量池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。&lt;/p&gt;
&lt;p&gt;Intern()是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。幸好在Oracle JDK 8u20之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，并不需&lt;br&gt;要Java类库做什么修改。注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用G1 GC：&lt;br&gt;-XX:+UseStringDeduplication&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="String" scheme="https://masonnpe.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>并行数组</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/并行数组/</id>
    <published>2018-11-03T10:56:30.580Z</published>
    <updated>2018-11-03T10:56:43.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacodegeeks.java8.parallel.arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] arrayOfLong = <span class="keyword">new</span> <span class="keyword">long</span> [ <span class="number">20000</span> ];        </span><br><span class="line"></span><br><span class="line">        Arrays.parallelSetAll( arrayOfLong, </span><br><span class="line">            index -&gt; ThreadLocalRandom.current().nextInt( <span class="number">1000000</span> ) );</span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( <span class="number">10</span> ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + <span class="string">" "</span> ) );</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Arrays.parallelSort( arrayOfLong );        </span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( <span class="number">10</span> ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + <span class="string">" "</span> ) );</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 </span><br><span class="line">Sorted: 39 220 263 268 325 607 655 678 723 793</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并行数组&quot;&gt;&lt;a href=&quot;#并行数组&quot; class=&quot;headerlink&quot; title=&quot;并行数组&quot;&gt;&lt;/a&gt;并行数组&lt;/h2&gt;&lt;p&gt;Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是&lt;code&gt;parallelSort()&lt;/code&gt;，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>接口的默认方法和静态方法</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/接口的默认方法和静态方法/</id>
    <published>2018-11-03T10:56:04.104Z</published>
    <updated>2018-11-03T11:29:26.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h2><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p><a id="more"></a><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，我们可以直接用接口调用这些静态方法。例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码片段整合了默认方法和静态方法的使用场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用接口的静态方法，并且传递DefaultableImpl的构造函数引用来构建对象</span></span><br><span class="line">    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="keyword">new</span> );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line"><span class="comment">// 调用接口的静态方法，并且传递OverridableImpl的构造函数引用来构建对象</span></span><br><span class="line">    defaulable = DefaulableFactory.create( OverridableImpl::<span class="keyword">new</span> );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default implementation</span><br><span class="line">Overridden implementation</span><br></pre></td></tr></table></figure><p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给<code>java.util.Collection</code>接口添加新方法，如<code>stream()</code>、<code>parallelStream()</code>、<code>forEach()</code>和<code>removeIf()</code>等等。</p><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口的默认方法和静态方法&quot;&gt;&lt;a href=&quot;#接口的默认方法和静态方法&quot; class=&quot;headerlink&quot; title=&quot;接口的默认方法和静态方法&quot;&gt;&lt;/a&gt;接口的默认方法和静态方法&lt;/h2&gt;&lt;p&gt;Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。&lt;/p&gt;
&lt;h3 id=&quot;默认方法&quot;&gt;&lt;a href=&quot;#默认方法&quot; class=&quot;headerlink&quot; title=&quot;默认方法&quot;&gt;&lt;/a&gt;默认方法&lt;/h3&gt;&lt;p&gt;默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。&lt;/p&gt;
&lt;p&gt;默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Defaulable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Interfaces now allow default methods, the implementer may or &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// may not implement (override) them.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;notRequired&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Default implementation&quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DefaultableImpl&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Defaulable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OverridableImpl&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Defaulable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;notRequired&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Overridden implementation&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Optional</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/Optional/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/Optional/</id>
    <published>2018-11-03T10:55:07.423Z</published>
    <updated>2018-11-03T11:19:39.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java应用中最常见的bug就是空指针异常</p><p><code>Optional</code>仅仅是一个容器，可以存放T类型的值或者<code>null</code>。它提供了一些有用的接口来避免显式的<code>null</code>检查，可以参考Java 8官方文档了解更多细节。</p><table><thead><tr><th>method</th><th>description</th></tr></thead><tbody><tr><td>isPresent</td><td>有值返回true 否则返回false</td></tr><tr><td>get()</td><td>有值时返回值  没有抛出异常</td></tr><tr><td>orElse</td><td>有值时返回值  没有返回默认值</td></tr><tr><td>orElseGet</td><td>有值时返回值  没有返回一个supplier接口生成的值</td></tr><tr><td>map</td><td>只存在就执行mapping函数调用,以将现有Optional实例的值转换成新的值</td></tr></tbody></table><a id="more"></a><h2 id="创建Optional"><a href="#创建Optional" class="headerlink" title="创建Optional"></a>创建Optional</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"><span class="comment">// 空的optional</span></span><br><span class="line">Optional&lt;Apple&gt; optApple=Optional.empty(); </span><br><span class="line"><span class="comment">// 值为nul抛出异常</span></span><br><span class="line">Optional&lt;Apple&gt; optApple1=Optional.of(apple);   </span><br><span class="line"><span class="comment">//  值为null 返回空的optional</span></span><br><span class="line">Optional&lt;Apple&gt; optApple2=Optional.ofNullable(apple);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Optional&quot;&gt;&lt;a href=&quot;#Optional&quot; class=&quot;headerlink&quot; title=&quot;Optional&quot;&gt;&lt;/a&gt;Optional&lt;/h2&gt;&lt;p&gt;Java应用中最常见的bug就是空指针异常&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt;仅仅是一个容器，可以存放T类型的值或者&lt;code&gt;null&lt;/code&gt;。它提供了一些有用的接口来避免显式的&lt;code&gt;null&lt;/code&gt;检查，可以参考Java 8官方文档了解更多细节。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isPresent&lt;/td&gt;
&lt;td&gt;有值返回true 否则返回false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get()&lt;/td&gt;
&lt;td&gt;有值时返回值  没有抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orElse&lt;/td&gt;
&lt;td&gt;有值时返回值  没有返回默认值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;orElseGet&lt;/td&gt;
&lt;td&gt;有值时返回值  没有返回一个supplier接口生成的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;只存在就执行mapping函数调用,以将现有Optional实例的值转换成新的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Optional" scheme="https://masonnpe.github.io/tags/Optional/"/>
    
  </entry>
  
  <entry>
    <title>JVM故障引起的问题</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/JVM%E6%95%85%E9%9A%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/JVM故障引起的问题/</id>
    <published>2018-11-03T09:44:39.858Z</published>
    <updated>2018-11-03T11:35:06.944Z</updated>
    
    <content type="html"><![CDATA[<ul><li>nio操作用到堆外内存，堆外内存只能等老年代满了以后fullgc 顺便回收一下，否则会一直等到oom</li><li>异步处理  等待的线程太多  积压了很多socket，jvm直接崩溃，所有改成生产者消费者的模式</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;nio操作用到堆外内存，堆外内存只能等老年代满了以后fullgc 顺便回收一下，否则会一直等到oom&lt;/li&gt;
&lt;li&gt;异步处理  等待的线程太多  积压了很多socket，jvm直接崩溃，所有改成生产者消费者的模式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能监控和故障处理工具</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/JVM性能监控和故障处理工具/</id>
    <published>2018-11-03T09:43:30.440Z</published>
    <updated>2018-11-03T11:35:03.350Z</updated>
    
    <content type="html"><![CDATA[<ul><li>jps查看虚拟机进程状态  -l  主类的全名  -v  数据jvm参数</li><li>jstat看虚拟机状态  jstat -gc 6424  jstat -gcutil 6424</li><li>jinfo 看jvm的参数  jinfo -flag CMSInitiatingOccupancyFraction 5192</li><li>jmap -dump:format=b,file=D:\DUMP.bin 5192  生成堆转储快照  jmap -heap 5192  堆详情信息</li><li>jhat D:\DUMP.bin  分析dump</li><li>jstack 5192 打印堆栈信息</li><li>jconsole、visualVM可视化工具</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;jps查看虚拟机进程状态  -l  主类的全名  -v  数据jvm参数&lt;/li&gt;
&lt;li&gt;jstat看虚拟机状态  jstat -gc 6424  jstat -gcutil 6424&lt;/li&gt;
&lt;li&gt;jinfo 看jvm的参数  jinfo -flag CMSInitiatingOccupancyFraction 5192&lt;/li&gt;
&lt;li&gt;jmap -dump:format=b,file=D:\DUMP.bin 5192  生成堆转储快照  jmap -heap 5192  堆详情信息&lt;/li&gt;
&lt;li&gt;jhat D:\DUMP.bin  分析dump&lt;/li&gt;
&lt;li&gt;jstack 5192 打印堆栈信息&lt;/li&gt;
&lt;li&gt;jconsole、visualVM可视化工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>引用类型</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/引用类型/</id>
    <published>2018-11-03T08:54:25.887Z</published>
    <updated>2018-11-03T11:13:56.046Z</updated>
    
    <content type="html"><![CDATA[<p>判定对象是否可被回收都与引用有关，在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure><p>通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM）使程序异常终止，也不会随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><a id="more"></a><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure><p>软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>android图片缓存框架中，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾<br>回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>应用场景：弱应用同样可用于内存敏感的缓存。</p><p>在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 fnalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如<br>果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之<br>前采取一些程序行动。<br>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p><p>这种引用的get()方法返回总是null，所以，可以想象，在平常的项目开发肯定用的少。但是根据这种引用的特点，我想可以通过监控这类引用，来进行一些垃圾清理的动作</p><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>引用队列（ReferenceQueue）使用<br>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM会在特定时机将引用enqueue到队列里，我们可以<br>从队列里获取引用（remove方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有意义了。看看下面的<br>示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被fnalize了，处于幻象可达状态），执行后期处理逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object counter = new Object();</span><br><span class="line">ReferenceQueue refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; p = new PhantomReference&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = null;</span><br><span class="line">Sysem.gc();</span><br><span class="line">try &#123;</span><br><span class="line"> // Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞</span><br><span class="line"> Reference&lt;Object&gt; ref = refQueue.remove(1000L);</span><br><span class="line"> if (ref != null) &#123;</span><br><span class="line"> // do something</span><br><span class="line"> &#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"> // Handle it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判定对象是否可被回收都与引用有关，在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。&lt;/p&gt;
&lt;h2 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h2&gt;&lt;h3 id=&quot;强引用&quot;&gt;&lt;a href=&quot;#强引用&quot; class=&quot;headerlink&quot; title=&quot;强引用&quot;&gt;&lt;/a&gt;强引用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object obj = new Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM）使程序异常终止，也不会随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="Reference" scheme="https://masonnpe.github.io/tags/Reference/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/JVM%E5%8F%82%E6%95%B0/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/JVM参数/</id>
    <published>2018-11-03T08:51:19.567Z</published>
    <updated>2018-11-03T11:33:43.218Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">Java HotSpot VM Options文档</a>官网的这份文档有点老了不知道新的在哪儿，可以做参考</p><h2 id="内存和GC"><a href="#内存和GC" class="headerlink" title="内存和GC"></a>内存和GC</h2><p>-XX:MaxDirectMemorySize    堆外内存的最大值</p><p>-XX:MetaspaceSize=128m  Metaspace初始大小   第一次扩张会造成JVM停顿，spring aop后类比较多</p><p>-XX:MaxMetaspaceSize=512m    Metaspace最大大小   设一个更大的Max值以求保险，防止将内存用光</p><p>-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly   内存达到75%主动CMS GC</p><p>-XX:+ExplicitGCInvokesConcurrent       让full gc时使用CMS算法，不是全程停顿</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p> -XX:AutoBoxCacheMax=20000     加大Integer Cache   自动装箱时缓冲中有的直接从缓存拿</p><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>-Xloggc:/dev/shm/gc-myapp.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails     打印gc日志</p><p>-XX:+PrintCommandLineFlags    将每次启动的参数输出到stdout</p><p>-XX:-OmitStackTraceInFastThrow     输出完整栈的日志</p><p>-XX:ErrorFile =${LOGDIR}/hs_err_%p.log    JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</p><p>-XX:+HeapDumpOnOutOfMemoryError   在OOM时，输出一个dump.core文件，记录当时的堆内存快照     对内存快照目录设置<code>-XX:HeapDumpPath=${LOGDIR}/</code></p><p>-XX:+PrintGCApplicationStoppedTime      打印清晰的完整的GC停顿时间外，还可以打印其他的JVM停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等</p><p>-XX:+PrintPromotionFailure       多大的新生代对象晋升到老生代失败从而引发Full GC的</p><p>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 -XX:+UnlockDiagnosticVMOptions -XX:-DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm-myapp.log        开启安全点日志</p><a id="more"></a><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td></tr><tr><td>-Xmx</td><td>最大堆大小</td></tr><tr><td>-Xss</td><td>线程占用栈空间大小，默认1m（以前是256k），可以适当调小，节约空间开启更多的线程</td></tr><tr><td>-Xmn</td><td>新生代的大小  JDK默认新生代占堆大小的1/3，调大可以让对象尽量在新生代被回收掉，不进入老年代</td></tr></tbody></table><h4 id="Behavioral-Options"><a href="#Behavioral-Options" class="headerlink" title="Behavioral Options"></a>Behavioral Options</h4><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:-AllowUserSignalHandlers</td><td>Do not complain if the application installs signal handlers. (Relevant to Solaris and Linux only.)</td></tr><tr><td>-XX:AltStackSize=16384</td><td>Alternate signal stack size (in Kbytes). (Relevant to Solaris only, removed from 5.0.)</td></tr><tr><td>-XX:-DisableExplicitGC</td><td>By default calls to System.gc() are enabled (-XX:-DisableExplicitGC). Use -XX:+DisableExplicitGC to disable calls to System.gc(). Note that the JVM still performs garbage collection when necessary.</td></tr><tr><td>-XX:+FailOverToOldVerifier</td><td>Fail over to old verifier when the new type checker fails. (Introduced in 6.)</td></tr><tr><td>-XX:+HandlePromotionFailure</td><td>The youngest generation collection does not require a guarantee of full promotion of all live objects. (Introduced in 1.4.2 update 11) [5.0 and earlier: false.]</td></tr><tr><td>-XX:+MaxFDLimit</td><td>Bump the number of file descriptors to max. (Relevant  to Solaris only.)</td></tr><tr><td>-XX:PreBlockSpin=10</td><td>Spin count variable for use with -XX:+UseSpinning. Controls the maximum spin iterations allowed before entering operating system thread synchronization code. (Introduced in 1.4.2.)</td></tr><tr><td>-XX:-RelaxAccessControlCheck</td><td>Relax the access control checks in the verifier. (Introduced in 6.)</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr><tr><td>-XX:+UseAltSigs</td><td>Use alternate signals instead of SIGUSR1 and SIGUSR2 for VM internal signals. (Introduced in 1.3.1 update 9, 1.4.1. Relevant to Solaris only.)</td></tr><tr><td>-XX:+UseBoundThreads</td><td>Bind user level threads to kernel threads. (Relevant to Solaris only.)</td></tr><tr><td>-XX:-UseConcMarkSweepGC</td><td>Use concurrent mark-sweep collection for the old generation. (Introduced in 1.4.1)</td></tr><tr><td>-XX:+UseGCOverheadLimit</td><td>Use a policy that limits the proportion of the VM’s time that is spent in GC before an OutOfMemory error is thrown. (Introduced in 6.)</td></tr><tr><td>-XX:+UseLWPSynchronization</td><td>Use LWP-based instead of thread based synchronization. (Introduced in 1.4.0. Relevant to Solaris only.)</td></tr><tr><td>-XX:-UseParallelGC</td><td>Use parallel garbage collection for scavenges. (Introduced in 1.4.1)</td></tr><tr><td>-XX:-UseParallelOldGC</td><td>Use parallel garbage collection for the full collections. Enabling this option automatically sets -XX:+UseParallelGC. (Introduced in 5.0 update 6.)</td></tr><tr><td>-XX:-UseSerialGC</td><td>Use serial garbage collection. (Introduced in 5.0.)</td></tr><tr><td>-XX:-UseSpinning</td><td>Enable naive spinning on Java monitor before entering operating system thread synchronizaton code. (Relevant to 1.4.2 and 5.0 only.) [1.4.2, multi-processor Windows platforms: true]</td></tr><tr><td>-XX:+UseTLAB</td><td>Use thread-local object allocation (Introduced in 1.4.0, known as UseTLE prior to that.) [1.4.2 and earlier, x86 or with -client: false]</td></tr><tr><td>-XX:+UseSplitVerifier</td><td>Use the new type checker with StackMapTable attributes. (Introduced in 5.0.)[5.0: false]</td></tr><tr><td>-XX:+UseThreadPriorities</td><td>Use native thread priorities.</td></tr><tr><td>-XX:+UseVMInterruptibleIO</td><td>Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. (Introduced in 6. Relevant to Solaris only.)</td></tr></tbody></table><hr><h4 id="Garbage-First-G1-Garbage-Collection-Options"><a href="#Garbage-First-G1-Garbage-Collection-Options" class="headerlink" title="Garbage First (G1) Garbage Collection Options"></a>Garbage First (G1) Garbage Collection Options</h4><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>Use the Garbage First (G1) Collector</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to achieve it.</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=n</td><td>Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes ‘do constant GC cycles’. The default value is 45.</td></tr><tr><td>-XX:NewRatio=n</td><td>老年代/新生代. 默认2.</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>eden/survivor值. 默认8.</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>对象在Survivor区最多熬过多少次Young GC后晋升到年老代，调大让对象在新生代多存活几次，默认15</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>Sets the number of threads used during parallel phases of the garbage collectors. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>Number of threads concurrent garbage collectors will use. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:G1ReservePercent=n</td><td>Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure. The default value is 10.</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td>With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The minimum value is 1Mb and the maximum value is 32Mb.</td></tr></tbody></table><hr><h4 id="Performance-Options"><a href="#Performance-Options" class="headerlink" title="Performance Options"></a>Performance Options</h4><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+AggressiveOpts</td><td>Turn on point performance compiler optimizations that are expected to be default in upcoming releases. (Introduced in 5.0 update 6.)</td></tr><tr><td>-XX:CompileThreshold=10000</td><td>Number of method invocations/branches before compiling [-client: 1,500]</td></tr><tr><td>-XX:LargePageSizeInBytes=4m</td><td>Sets the large page size used for the Java heap. (Introduced in 1.4.0 update 1.) [amd64: 2m.]</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后，如果发现空闲堆内存大于70%时，则收缩堆内存的最大值</td></tr><tr><td>-XX:MaxNewSize=size</td><td>Maximum size of new generation (in bytes). Since 1.4, MaxNewSize is computed as a function of NewRatio. [1.3.1 Sparc: 32m; 1.3.1 x86: 2.5m.]</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后，如果发现空闲堆内存小于40%时，则放大堆内存的最大值，但不超过固定最大值</td></tr><tr><td>-XX:NewRatio=2</td><td>Ratio of old/new generation sizes. [Sparc -client: 8; x86 -server: 8; x86 -client: 12.]-client: 4 (1.3) 8 (1.3.1+), x86: 12]</td></tr><tr><td>-XX:NewSize=2m</td><td>Default size of new generation (in bytes) [5.0 and newer: 64 bit VMs are scaled 30% larger; x86: 1m; x86, 5.0 and older: 640k]</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>Reserved code cache size (in bytes) - maximum code cache size. [Solaris 64-bit, amd64, and -server x86: 2048m; in 1.5.0_06 and earlier, Solaris 64-bit and amd64: 1024m.]</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>Ratio of eden/survivor space size [Solaris amd64: 6; Sparc in 1.3.1: 25; other Solaris platforms in 5.0 and earlier: 32]</td></tr><tr><td>-XX:TargetSurvivorRatio=50</td><td>Desired percentage of survivor space used after scavenge.</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>Thread Stack Size (in Kbytes). (0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td></tr><tr><td>-XX:-UseBiasedLocking</td><td>取消偏向锁，大量多线程并发，锁会从偏向所升级，取消反而有性能提升</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>Use optimized versions of Get<primitive>Field.</primitive></td></tr><tr><td>-XX:-UseISM</td><td>Use Intimate Shared Memory. [Not accepted for non-Solaris platforms.] For details, see <a href="https://www.oracle.com/technetwork/java/ism-139376.html" target="_blank" rel="noopener">Intimate Shared Memory</a>.</td></tr><tr><td>-XX:+UseLargePages</td><td>Use large page memory. (Introduced in 5.0 update 5.) For details, see <a href="https://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html" target="_blank" rel="noopener">Java Support for Large Memory Pages</a>.</td></tr><tr><td>-XX:+UseMPSS</td><td>Use Multiple Page Size Support w/4mb pages for the heap. Do not use with ISM as this replaces the need for ISM. (Introduced in 1.4.0 update 1, Relevant to Solaris 9 and newer.) [1.4.1 and earlier: false]</td></tr><tr><td>-XX:+UseStringCache</td><td>Enables caching of commonly allocated strings.</td></tr><tr><td>-XX:AllocatePrefetchLines=1</td><td>Number of cache lines to load after the last object allocation using prefetch instructions generated in JIT compiled code. Default values are 1 if the last allocated object was an instance and 3 if it was an array.</td></tr><tr><td>-XX:AllocatePrefetchStyle=1</td><td>Generated code style for prefetch instructions. 0 - no prefetch instructions are generate<em>d</em>, 1 - execute prefetch instructions after each allocation, 2 - use TLAB allocation watermark pointer to gate when prefetch instructions are executed.</td></tr><tr><td>-XX:+UseCompressedStrings</td><td>Use a byte[] for Strings which can be represented as pure ASCII. (Introduced in Java 6 Update 21 Performance Release)</td></tr><tr><td>-XX:+OptimizeStringConcat</td><td>Optimize String concatenation operations where possible. (Introduced in Java 6 Update 20)</td></tr></tbody></table><hr><h4 id="Debugging-Options"><a href="#Debugging-Options" class="headerlink" title="Debugging Options"></a>Debugging Options</h4><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:-CITime</td><td>Prints time spent in JIT Compiler. (Introduced in 1.4.0.)</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid<pid>.log</pid></td><td>If an error occurs, save the error data to this file. (Introduced in 6.)</td></tr><tr><td>-XX:-ExtendedDTraceProbes</td><td>Enable performance-impacting <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/dtrace.html" target="_blank" rel="noopener">dtrace</a> probes. (Introduced in 6. Relevant to Solaris only.)</td></tr><tr><td>-XX:HeapDumpPath=./java_pid<pid>.hprof</pid></td><td>设置内存快照目录</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>在OOM时，输出一个dump.core文件，记录当时堆内存快照</td></tr><tr><td>-XX:OnError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>Run user-defined commands on fatal error. (Introduced in 1.4.2 update 9.)</td></tr><tr><td>-XX:OnOutOfMemoryError=”<cmd args="">;  <cmd args="">“</cmd></cmd></td><td>Run user-defined commands when an OutOfMemoryError is first thrown. (Introduced in 1.4.2 update 12, 6)</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>Print a histogram of class instances on Ctrl-Break. <em>Manageable</em>. (Introduced in 1.4.2.) The <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html" target="_blank" rel="noopener">jmap -histo</a>command provides equivalent functionality.</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>Print java.util.concurrent locks in Ctrl-Break thread dump. <em>Manageable</em>. (Introduced in 6.) The <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstack.html" target="_blank" rel="noopener">jstack -l</a>command provides equivalent functionality.</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>Print flags that appeared on the command line. (Introduced in 5.0.)</td></tr><tr><td>-XX:-PrintCompilation</td><td>Print message when a method is compiled.</td></tr><tr><td>-XX:-PrintGC</td><td>Print messages at garbage collection. <em>Manageable</em>.</td></tr><tr><td>-XX:-PrintGCDetails</td><td>Print more details at garbage collection. <em>Manageable</em>. (Introduced in 1.4.0.)</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>Print timestamps at garbage collection. <em>Manageable</em>(Introduced in 1.4.0.)</td></tr><tr><td>-XX:-PrintTenuringDistribution</td><td>查看survivor区对象大部分多少次进老年代</td></tr><tr><td>-XX:-PrintAdaptiveSizePolicy</td><td>Enables printing of information about adaptive generation sizing.</td></tr><tr><td>-XX:-TraceClassLoading</td><td>Trace loading of classes.</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>Trace all classes loaded in order referenced (not loaded). (Introduced in 1.4.2.)</td></tr><tr><td>-XX:-TraceClassResolution</td><td>Trace constant pool resolutions. (Introduced in 1.4.2.)</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>Trace unloading of classes.</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>Trace recording of loader constraints. (Introduced in 6.)</td></tr><tr><td>-XX:+PerfDataSaveToFile</td><td>Saves jvmstat binary data on exit.</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>Sets the number of garbage collection threads in the young and old parallel garbage collectors. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:+UseCompressedOops</td><td>Enables the use of compressed pointers (object references represented as 32 bit offsets instead of 64-bit pointers) for optimized 64-bit performance with Java heap sizes less than 32gb.</td></tr><tr><td>-XX:+AlwaysPreTouch</td><td>为了避免多次内存分配的开销，让HotSpot VM在commit内存时跑个循环来强制保证申请的内存真的commit了</td></tr><tr><td>-XX:AllocatePrefetchDistance=n</td><td>Sets the prefetch distance for object allocation. Memory about to be written with the value of new objects is prefetched into cache at this distance (in bytes) beyond the address of the last allocated object. Each Java thread has its own allocation point. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:InlineSmallCode=n</td><td>Inline a previously compiled method only if its generated native code size is less than this. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:MaxInlineSize=35</td><td>Maximum bytecode size of a method to be inlined.</td></tr><tr><td>-XX:FreqInlineSize=n</td><td>Maximum bytecode size of a frequently executed method to be inlined. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:LoopUnrollLimit=n</td><td>Unroll loop bodies with server compiler intermediate representation node count less than this value. The limit used by the server compiler is a function of this value, not the actual value. The default value varies with the platform on which the JVM is running.</td></tr><tr><td>-XX:InitialTenuringThreshold=7</td><td>Sets the initial tenuring threshold for use in adaptive GC sizing in the parallel young collector. The tenuring threshold is the number of times an object survives a young collection before being promoted to the old, or tenured, generation.</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>Sets the maximum tenuring threshold for use in adaptive GC sizing. The current largest value is 15. The default value is 15 for the parallel collector and is 4 for CMS.</td></tr><tr><td>-Xloggc:<filename></filename></td><td>Log GC verbose output to specified file. The verbose output is controlled by the normal verbose GC flags.</td></tr><tr><td>-XX:-UseGCLogFileRotation</td><td>Enabled GC log rotation, requires -Xloggc.</td></tr><tr><td>-XX:NumberOfGClogFiles=1</td><td>Set the number of files to use when rotating logs, must be &gt;= 1. The rotated log files will use the following naming scheme, <filename>.0, <filename>.1, …, <filename>.n-1.</filename></filename></filename></td></tr><tr><td>-XX:GCLogFileSize=8K</td><td>The size of the log file at which point the log will be rotated, must be &gt;= 8K.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java HotSpot VM Options文档&lt;/a&gt;官网的这份文档有点老了不知道新的在哪儿，可以做参考&lt;/p&gt;
&lt;h2 id=&quot;内存和GC&quot;&gt;&lt;a href=&quot;#内存和GC&quot; class=&quot;headerlink&quot; title=&quot;内存和GC&quot;&gt;&lt;/a&gt;内存和GC&lt;/h2&gt;&lt;p&gt;-XX:MaxDirectMemorySize    堆外内存的最大值&lt;/p&gt;
&lt;p&gt;-XX:MetaspaceSize=128m  Metaspace初始大小   第一次扩张会造成JVM停顿，spring aop后类比较多&lt;/p&gt;
&lt;p&gt;-XX:MaxMetaspaceSize=512m    Metaspace最大大小   设一个更大的Max值以求保险，防止将内存用光&lt;/p&gt;
&lt;p&gt;-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly   内存达到75%主动CMS GC&lt;/p&gt;
&lt;p&gt;-XX:+ExplicitGCInvokesConcurrent       让full gc时使用CMS算法，不是全程停顿&lt;/p&gt;
&lt;h2 id=&quot;性能&quot;&gt;&lt;a href=&quot;#性能&quot; class=&quot;headerlink&quot; title=&quot;性能&quot;&gt;&lt;/a&gt;性能&lt;/h2&gt;&lt;p&gt; -XX:AutoBoxCacheMax=20000     加大Integer Cache   自动装箱时缓冲中有的直接从缓存拿&lt;/p&gt;
&lt;h2 id=&quot;运维&quot;&gt;&lt;a href=&quot;#运维&quot; class=&quot;headerlink&quot; title=&quot;运维&quot;&gt;&lt;/a&gt;运维&lt;/h2&gt;&lt;p&gt;-Xloggc:/dev/shm/gc-myapp.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails     打印gc日志&lt;/p&gt;
&lt;p&gt;-XX:+PrintCommandLineFlags    将每次启动的参数输出到stdout&lt;/p&gt;
&lt;p&gt;-XX:-OmitStackTraceInFastThrow     输出完整栈的日志&lt;/p&gt;
&lt;p&gt;-XX:ErrorFile =${LOGDIR}/hs_err_%p.log    JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID&lt;/p&gt;
&lt;p&gt;-XX:+HeapDumpOnOutOfMemoryError   在OOM时，输出一个dump.core文件，记录当时的堆内存快照     对内存快照目录设置&lt;code&gt;-XX:HeapDumpPath=${LOGDIR}/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-XX:+PrintGCApplicationStoppedTime      打印清晰的完整的GC停顿时间外，还可以打印其他的JVM停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等&lt;/p&gt;
&lt;p&gt;-XX:+PrintPromotionFailure       多大的新生代对象晋升到老生代失败从而引发Full GC的&lt;/p&gt;
&lt;p&gt;-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 -XX:+UnlockDiagnosticVMOptions -XX:-DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=/dev/shm/vm-myapp.log        开启安全点日志&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://masonnpe.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC日志</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/GC%E6%97%A5%E5%BF%97/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/GC日志/</id>
    <published>2018-11-03T08:50:50.135Z</published>
    <updated>2018-11-03T11:34:55.734Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾收集器长时间停顿，表现在 Web 页面上可能是页面响应码 500 之类的服务器错误问题，如果是个支付过程可能会导致支付失败，将造成公司的直接经济损失。</p><h3 id="MetaSpace内存溢出"><a href="#MetaSpace内存溢出" class="headerlink" title="MetaSpace内存溢出"></a>MetaSpace内存溢出</h3><p><code>JDK8</code> 使用 <code>MetaSpace</code> 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆</p><p>JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 <code>MetaSpace</code> ,如果不指定该区域的大小，JVM 将会动态的调整。</p><p>可以使用 <code>-XX:MaxMetaspaceSize=10M</code> 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 <code>OOM</code></p><p>动态代理对象太多也会 oom动态代理生成的对象在Jvm中指向的不是同一个地址，它只是与源对象有相同的hashcode值而已</p><a id="more"></a><h2 id="CMS-concurrent-mode-failure"><a href="#CMS-concurrent-mode-failure" class="headerlink" title="CMS (concurrent mode failure)"></a>CMS (concurrent mode failure)</h2><ul><li>老年代碎片化严重，无法容纳新生代提升上来的大对象</li><li>新生代来不及回收，老年代被用完</li></ul><p>发送这种情况，应用线程将会全部停止（相当于网站这段时间无法响应用户请求），进行压缩式垃圾收集（回退到 Serial Old 算法）</p><p>解决办法：</p><ul><li>新生代提升过快问题：（1）如果频率太快的话，说明空间不足，首先可以尝试调大新生代空间和晋升阈值。（2）如果内存有限，可以设置 CMS 垃圾收集在老年代占比达到多少时启动来减少问题发生频率（越早启动问题发生频率越低，但是会降低吞吐量，具体得多调整几次找到平衡点），参数如下：如果没有第二个参数，会随着 JVM 动态调节 CMS 启动时间</li></ul><p>-XX:CMSInitiatingOccupancyFraction=68 （默认是 68）</p><p>-XX:+UseCMSInitiatingOccupancyOnly</p><ul><li>老年代碎片严重问题：（1）如果频率太快或者 Full GC 后空间释放不多的话，说明空间不足，首先可以尝试调大老年代空间（2）如果内存不足，可以设置进行 n 次 CMS 后进行一次压缩式 Full GC，参数如下：</li></ul><p>-XX:+UseCMSCompactAtFullCollection：允许在 Full GC 时，启用压缩式 GC</p><p>-XX:CMSFullGCBeforeCompaction=n     在进行 n 次，CMS 后，进行一次压缩的 Full GC，用以减少 CMS 产生的碎片</p><h2 id="CMS-promotion-failed"><a href="#CMS-promotion-failed" class="headerlink" title="CMS (promotion failed)"></a>CMS (promotion failed)</h2><p>在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）。 这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。  再进一步， 如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。</p><p>提升失败日志：  </p><p>提升失败原因：Minor GC 时发现 Survivor 空间放不下，而老年代的空闲也不够</p><ul><li>新生代提升太快</li><li>老年代碎片太多，放不下大对象提升（表现为老年代还有很多空间但是，出现了 promotion failed）</li></ul><p>解决方法：是调整年轻代和年老代的比例，还有CMSGC的时机</p><p>​       两条和上面 concurrent mode failure 一样</p><p>​       另一条，是因为 Survivor Unused 不足，那么可以尝试调大 Survivor 来尝试下 </p><p>三. 在 GC 的时候其他系统活动影响</p><p>有些时候系统活动诸如内存换入换出（vmstat）、网络活动（netstat）、I/O （iostat）在 GC 过程中发生会使 GC 时间变长。</p><p>前提是你的服务器上是有 SWAP 区域（用 top、 vmstat 等命令可以看出）用于内存的换入换出，那么操作系统可能会将 JVM 中不活跃的内存页换到 SWAP 区域用以释放内存给线程使用（这也透露出内存开始不够用了）。内存换入换出是一个开销巨大的磁盘操作，比内存访问慢好几个数量级。</p><p>看一段 GC 日志：耗时 29.47 秒 </p><p>再看看此时的 vmstat 命令中 si、so 列的数值，如果数值大说明换入换出严重，这是内存不足的表现。</p><p>解决方法：减少线程，这样可以降低内存换入换出；增加内存；如果是 JVM 内存设置过大导致线程所用内存不足，则适当调低 -Xmx 和 -Xms。</p><p>五. 总结</p><p>​       长时间停顿问题的排查及解决首先需要一定的信息和方法论：</p><ul><li>详细的 GC 日志</li><li>借助 Linux 平台下的 iostat、vmstat、netstat、mpstat 等命令监控系统情况</li><li>查看 GC 日志中是否出现了上述的典型内存异常问题（promotion failed, concurrent mode failure），整体来说把上述两个典型内存异常情况控制在可接受的发生频率即可，对 CMS 碎片问题来说杜绝以上问题似乎不太可能，只能靠 G1 来解决了</li><li>是不是 JVM 本身的 bug 导致的</li><li>如果程序没问题，参数调了几次还是不能解决，可能说明流量太大，需要加机器把压力分散到更多 JVM 上</li></ul><h2 id="gc常见错误"><a href="#gc常见错误" class="headerlink" title="gc常见错误"></a>gc常见错误</h2><p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>原因：Heap内存溢出，意味着Young和Old generation的内存不够。</p><p>解决：调整java启动参数-Xms -Xmx 来增加Heap内存。</p><p><strong>java.lang.OutOfMemoryError: unable to create new native thread</strong></p><p>原因：Stack空间不足以创建额外的线程，要么是创建的线程过多，要么是Stack空间确实小了。</p><p>解决：由于JVM没有提供参数设置总的stack空间大小，但可以设置单个线程栈的大小；而系统的用户空间一共是3G，除了Text/Data/BSS /MemoryMapping几个段之外，Heap和Stack空间的总量有限，是此消彼长的。因此遇到这个错误，可以通过两个途径解决：1.通过 -Xss启动参数减少单个线程栈大小，这样便能开更多线程（当然不能太小，太小会出现StackOverflowError）；2.通过-Xms -Xmx 两参数减少Heap大小，将内存让给Stack（前提是保证Heap空间够用）。</p><p><strong>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</strong></p><p>原因：这个错误比较少见（试着new一个长度1亿的数组看看），同样是由于Heap空间不足。如果需要new一个如此之大的数组，程序逻辑多半是不合理的。</p><p>解决：修改程序逻辑吧。或者也可以通过-Xmx来增大堆内存。</p><p>在GC花费了大量时间，却仅回收了少量内存时，也会报出OutOfMemoryError ，我只遇到过一两次。当使用-XX:+UseParallelGC或-XX:+UseConcMarkSweepGC收集器时，在上述情况下会报错，在 HotSpot GC Turning文档 上有说明：</p><p>The parallel(concurrent) collector will throw an OutOfMemoryError if too much time is being spent in garbage collection: if more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, an OutOfMemoryError will be thrown.</p><p>对这个问题，一是需要进行GC turning，二是需要优化程序逻辑。</p><p><strong>java.lang.StackOverflowError</strong></p><p>原因：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。</p><p>解决：优化程序设计，减少方法调用层次；调整-Xss参数增加线程栈大小。</p><p><strong>IOException: Too many open files</strong></p><p>原因： 这个是由于TCP connections 的buffer 大小不够用了。</p><p><strong>java.lang.OutOfMemoryError:Direct buffer memory</strong></p><p>解决：调整-XX:MaxDirectMemorySize=</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾收集器长时间停顿，表现在 Web 页面上可能是页面响应码 500 之类的服务器错误问题，如果是个支付过程可能会导致支付失败，将造成公司的直接经济损失。&lt;/p&gt;
&lt;h3 id=&quot;MetaSpace内存溢出&quot;&gt;&lt;a href=&quot;#MetaSpace内存溢出&quot; class=&quot;headerlink&quot; title=&quot;MetaSpace内存溢出&quot;&gt;&lt;/a&gt;MetaSpace内存溢出&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JDK8&lt;/code&gt; 使用 &lt;code&gt;MetaSpace&lt;/code&gt; 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆&lt;/p&gt;
&lt;p&gt;JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 &lt;code&gt;MetaSpace&lt;/code&gt; ,如果不指定该区域的大小，JVM 将会动态的调整。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;-XX:MaxMetaspaceSize=10M&lt;/code&gt; 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 &lt;code&gt;OOM&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;动态代理对象太多也会 oom动态代理生成的对象在Jvm中指向的不是同一个地址，它只是与源对象有相同的hashcode值而已&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://masonnpe.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/垃圾回收/</id>
    <published>2018-11-03T08:49:48.734Z</published>
    <updated>2018-11-03T11:47:20.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断是否可回收"><a href="#判断是否可回收" class="headerlink" title="判断是否可回收"></a>判断是否可回收</h2><p><strong>引用计数算法</strong></p><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收，JVM不使用</p><p><strong>可达性算法</strong></p><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p>在 Java 中 GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本级方法栈(Native方法)引用的对象</li><li>方法区中类静态变量引用的对象</li><li>方法区中的常量引用的对象</li></ul><a id="more"></a><p><strong>方法区回收</strong></p><p>主要是对常量池的回收和对类的卸载。在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h3><p>标记存活的对象，将未被标记的对象清除        </p><p>缺点：</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p><p>JVM新生代中是这么做的：新生代分为一块较大的 Eden区和两块较小的Survivor区，每次使用Eden区和其中一块Survivor区。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h3><p>将存活的对象集中起来，使其内存连续，将边界以外的内存清除</p><p>新生代使用：复制算法         老年代使用：标记 - 清除 或者 标记 - 整理</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.PNG" alt="垃圾收集器"></p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Client 模式下的默认新生代收集器，单线程的收集器，优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。缺点是回收时会将正在执行的线程暂停。适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上</p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>吞吐量 = 运行用户代码时间 / （运行用户代码时间  + 垃圾收集时间）<br>-XX:MaxGCPauseMillis=n  控制最大垃圾收集停顿时间<br>-XX:GCTimeRatio=n  设置吞吐量大小的垃圾收集时间占总时间的比率，设置为19  最大gc时间就占总的1/20<br>-XX:UseAdaptiveSizePolicy   GC  Ergonomics 动态调整java堆中各个区域的大小和年龄</p><p>多线程收集器。其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>-XX:ParallelGCThreads</p><p>Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数</p><p>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数</p><hr><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>CMS备用预案  Concurrent Mode Failusre时使用标记-整理算法</p><p>Serial收集器的老年代版本，它同样使用一个单线程执行收集，基于标记整理法，作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>标记-整理算法</p><p>Parallel Scavenge收集器的老年代版本，使用多线程和标记整理法，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器，可以用在注重吞吐量和CPU资源敏感的场合,UsePallelOldGC打开</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>标记-清除算法<br>减少回收停顿时间<br>碎片 -XX:CMSInitiatingOccupancyFraction  被使用多少后触发垃圾收集，提高cms触发百分比<br>Concurrent Mode Failure 启用Serial Old    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction 执行多少次不压缩FullGC后 来一次带压缩的 0 表示每次都压</span><br><span class="line">-XX:+UseConcMarkSweep</span><br></pre></td></tr></table></figure><p>Concurrent Mark Sweep，基于标记清除法。目标是解决Serial GC 的停顿问题，以达到最短回收时间，有高并发、高响应的特点</p><ol><li>初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</li><li>并发标记(CMS concurrenr mark)  进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿</li><li>重新标记(CMS remark)  为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li><li>并发清除(CMS concurrent sweep)不需要停顿</li></ol><p>缺点：</p><ol><li>产生大量碎片，大内存找不到连续的空间 会full gc    通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理，默认为0，即每次Full GC都对老生代进行碎片整理压缩。Full GC 不同于 老生代75%时触发的CMS GC，只在老生代达到100%，堆外内存满，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的</li><li>无法清除浮动垃圾  在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比。可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>占用cpu资源 导致程序变慢，吞吐量下降</li><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高</li></ol><hr><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>-XX:+UseG1GC 使用G1垃圾收集器</p><p>面向Server的垃圾收集器，相比CMS有不少改进，在多 CPU 和大内存的场景下有很好的性能。G1 可以直接对新生代和老年代一起回收 。优点：</p><ul><li>整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片</li><li>能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li></ul><p>通过引入 Region （区域）的概念，将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。通过记录每个 Region 垃圾回收时间以及回收所获得的空间，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><table><thead><tr><th>收集器</th><th>串行/并行/并发</th><th>新生代/老年代</th><th>算法</th><th>优先目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度</td><td>单CPU的Client模式</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度</td><td>单CPU的Client模式、CMS的后备预案</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度</td><td>多CPU时在Server模式下与CMS配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度</td><td>集中在互联网站或B/S系统服务端上的Java应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>新生代和老年代</td><td>标记-整理+复制算法</td><td>响应速度</td><td>面向服务端应用，将来替换CMS</td></tr></tbody></table><p>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序</p><p>并行指的是垃圾收集器和用户程序同时执行</p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><p><strong>对象优先在eden区分配内存</strong>，eden区空间不够时出发minor gc</p></li><li><p><strong>大对象直接进入老年代</strong>  -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制</p></li><li><p><strong>长期存活的进入老年代</strong>在新生代多次gc存活下来的进入老年代  -XX:MaxTenuringThreshold 用来定义经过多少次minor gc还存活后进入老年代</p></li><li><p><strong>动态对象年龄判定</strong>当 Survivor 中相同年龄所有对象大小的总和&gt; Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需经过 MaxTenuringThreshold 次gc</p></li><li><p><strong>空间分配担保</strong>在 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</p><blockquote><p>TLAB  thread local allcationnnotion buffer</p><p>在eden区   每隔线程都有自己的   TLAB  thread local allaction buffer</p></blockquote></li></ol><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><h3 id="minor-gc"><a href="#minor-gc" class="headerlink" title="minor gc"></a>minor gc</h3><p>当 eden 空间满时，就将触发一次 minor gc，清理eden区</p><h3 id="major-gc"><a href="#major-gc" class="headerlink" title="major gc"></a>major gc</h3><p>是清理老年代</p><h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>清理整个堆空间—包括年轻代和老年代</p><ul><li>空间分配担保失败触发full gc   minor gc之前检查 老年代最大可用连续空间是否&gt;新生代所有对象总空间</li><li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足 大对象直接进入老年代，长期存活的对象进入老年代，老年代没有足够大小的连续内存空间，触发full gc</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>如何查看当前的垃圾回收器<br>​    -XX:+PrintFlagsFinal<br>​    -XX:+PrintCommandLineFlags<br>​    server client<br>​    MBean</p><p>GC日志<br>​    1.输出日志<br>​    -XX:+PrintGCTimeStamps<br>​    -XX:+PrintGCDetails<br>​    -Xloggc:/home/administrator/james/gc.log<br>​    -XX:+PrintHeapAtGC<br>​    2.日志文件控制<br>​    -XX:-UseGCLogFileRotation<br>​    -XX:GCLogFileSize=8K<br>​    3.怎么看</p><p>JDK自带的 监控工具<br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html</a><br>​    jmap -heap pid 堆使用情况<br>​    jstat  -gcutil pid 1000<br>​    jstack  线程dump<br>​    jvisualvm<br>​    jconsole</p><p>MAT<br>​    <a href="http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html" target="_blank" rel="noopener">http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</a><br>​    -XX:+HeapDumpOnOutOfMemoryError<br>​    -XX:HeapDumpPath=/home/administrator/james/error.hprof</p><p>怀疑：<br>​    1.看GC日志  126719K-&gt;126719K(126720K)<br>​    2.dump<br>​    3.MAT<br>​        1.占用Retained Heap<br>​        2.看有没有GC Root指向</p><p>什么条件触发STW的Full GC呢？<br>Perm空间不足；<br>CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；<br>（promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc    ）</p><p>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；</p><p>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。<br>​<br>​<br>java -Xms8m -Xmx64m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+PrintHeapAtGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  &gt; catalina.out  2&gt;&amp;1 &amp;</p><p>java -Xms128m -Xmx128m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/administrator/james/error.hprof -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC  -XX:+UseCMSCompactAtFullCollection -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  &gt; catalina.out  2&gt;&amp;1 &amp;</p><p>java -Xms128m -Xmx128m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintHeapAtGC -XX:HeapDumpPath=/home/administrator/james/error.hprof -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseCMSCompactAtFullCollection -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  &gt; catalina.out  2&gt;&amp;1 &amp;</p><p>-XX:+CMSScavengeBeforeRemark</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;判断是否可回收&quot;&gt;&lt;a href=&quot;#判断是否可回收&quot; class=&quot;headerlink&quot; title=&quot;判断是否可回收&quot;&gt;&lt;/a&gt;判断是否可回收&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;引用计数算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收，JVM不使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可达性算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。&lt;/p&gt;
&lt;p&gt;在 Java 中 GC Roots 一般包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中局部变量表中引用的对象&lt;/li&gt;
&lt;li&gt;本级方法栈(Native方法)引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态变量引用的对象&lt;/li&gt;
&lt;li&gt;方法区中的常量引用的对象&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://masonnpe.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM组成</title>
    <link href="https://masonnpe.github.io/2018/11/03/JVM/JVM%E7%BB%84%E6%88%90/"/>
    <id>https://masonnpe.github.io/2018/11/03/JVM/JVM组成/</id>
    <published>2018-11-03T08:46:49.559Z</published>
    <updated>2018-11-03T08:53:32.358Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pgmrhouhm.bkt.clouddn.com/jvm.PNG" alt="JVM"></p><p>方法区和堆内存是线程<strong>共享</strong>的。程序计数器、虚拟机栈、本地方法栈是线程<strong>私有</strong>的</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存放已经被JVM加载的类的信息，如常量，静态变量、即时编译器编译后的代码等。</p><p>从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中，1.8 metaspace 放类加载信息</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/jmm.PNG" alt="jmm"></p><p>所有对象的创建都在这里进行分配，采取分代管理，分为新生代和老年代，执行不同的垃圾回收策略，所有<strong>实例域，静态域和数组元素</strong>都是放在堆内存中。常量池在堆中</p><a id="more"></a><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>指向当前线程执行的字节码行号，多线程切换时可以知道上一次运行的状态和位置</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="http://pgmrhouhm.bkt.clouddn.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.PNG" alt="虚拟机栈"></p><p>由一个个栈帧组成，每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用、方法的调用返回等信息，每创建一个栈帧压栈，当一个方法执行完毕之后则出栈</p><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>调用Native Method</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://pgmrhouhm.bkt.clouddn.com/jvm.PNG&quot; alt=&quot;JVM&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法区和堆内存是线程&lt;strong&gt;共享&lt;/strong&gt;的。程序计数器、虚拟机栈、本地方法栈是线程&lt;strong&gt;私有&lt;/strong&gt;的&lt;/p&gt;
&lt;h2 id=&quot;方法区&quot;&gt;&lt;a href=&quot;#方法区&quot; class=&quot;headerlink&quot; title=&quot;方法区&quot;&gt;&lt;/a&gt;方法区&lt;/h2&gt;&lt;p&gt;存放已经被JVM加载的类的信息，如常量，静态变量、即时编译器编译后的代码等。&lt;/p&gt;
&lt;p&gt;从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中，1.8 metaspace 放类加载信息&lt;/p&gt;
&lt;h2 id=&quot;堆内存&quot;&gt;&lt;a href=&quot;#堆内存&quot; class=&quot;headerlink&quot; title=&quot;堆内存&quot;&gt;&lt;/a&gt;堆内存&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://pgmrhouhm.bkt.clouddn.com/jmm.PNG&quot; alt=&quot;jmm&quot;&gt;&lt;/p&gt;
&lt;p&gt;所有对象的创建都在这里进行分配，采取分代管理，分为新生代和老年代，执行不同的垃圾回收策略，所有&lt;strong&gt;实例域，静态域和数组元素&lt;/strong&gt;都是放在堆内存中。常量池在堆中&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://masonnpe.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://masonnpe.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Stream流</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/Stream%E6%B5%81/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/Stream流/</id>
    <published>2018-11-03T08:03:54.550Z</published>
    <updated>2018-11-03T08:06:14.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Java8的新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。Steam API极大得简化了集合操作，Stream流配合Lambda表达式使用起来真是美滋滋，steam的另一个价值是创造性地支持并行处理。</p><p>优点：性能高，灵活，表达清楚</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>api分为两大类，中间操作相当于流水线，能对流水线上的东西进行各种处理，不会消耗流；终端操作消耗流，不能再对流进行操作</p><table><thead><tr><th>中间操作(流水线)</th><th></th></tr></thead><tbody><tr><td>filter</td><td>过滤</td></tr><tr><td>map</td><td>抽取流</td></tr><tr><td>limit</td><td>限制个数</td></tr><tr><td>skip</td><td>跳过个数</td></tr><tr><td>sorted</td><td>排序</td></tr><tr><td>distinct</td><td>去重</td></tr><tr><td>flagmap</td><td>合并到一起</td></tr></tbody></table><table><thead><tr><th>终端操作(消耗流)</th><th></th></tr></thead><tbody><tr><td>collect</td><td>收集</td></tr><tr><td>foreach</td><td>遍历</td></tr><tr><td>count</td><td>计数</td></tr><tr><td>anyMatch</td><td>至少匹配1个</td></tr><tr><td>allMatch</td><td>匹配所有</td></tr><tr><td>noneMatch</td><td>没有元素匹配</td></tr><tr><td>findAny</td><td>返回流中任意元素</td></tr><tr><td>reduce</td></tr></tbody></table><a id="more"></a><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        appleList.parallelStream().filter((e)-&gt;e.getWeight()&gt;<span class="number">50</span>)  <span class="comment">// 筛选重量&gt;50的苹果</span></span><br><span class="line">                .sorted(Comparator.comparing(Apple::getColor))    <span class="comment">// 根据苹果的颜色进行排序</span></span><br><span class="line">                .map(Apple::getWeight)                            <span class="comment">// 抽取苹果中的重量</span></span><br><span class="line">                .limit(<span class="number">3</span>)                                         <span class="comment">// 限定选3个</span></span><br><span class="line">                .distinct()                                       <span class="comment">// 去掉相同的元素</span></span><br><span class="line">                .collect(Collectors.toList());                    <span class="comment">// 转化成list</span></span><br><span class="line"></span><br><span class="line">        appleList.forEach(System.out::println); <span class="comment">// 打印每个苹果</span></span><br><span class="line">        appleList.stream().count();  <span class="comment">// 计算苹果的总个数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 对list根据苹果的颜色进行分组</span></span><br><span class="line">        Map&lt;String,List&lt;Apple&gt;&gt; map=appleList.parallelStream().collect(Collectors.groupingBy(Apple::getColor));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flagmap合并流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"hello"</span>);</span><br><span class="line">        names.add(<span class="string">"world"</span>);</span><br><span class="line">        List&lt;String&gt; a=names.stream().map((String e)-&gt;e.split(<span class="string">""</span>))</span><br><span class="line">                .flatMap(Arrays::stream)</span><br><span class="line">                .collect(Collectors.toList());<span class="comment">// 将两个单词，拆成单个字母并存为list</span></span><br><span class="line">        System.out.println(a.get(<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"hello"</span>);</span><br><span class="line">        names.add(<span class="string">"world"</span>);</span><br><span class="line">        String newstr=names.stream().map((String e)-&gt;e.split(<span class="string">""</span>))</span><br><span class="line">                .flatMap(Arrays::stream)</span><br><span class="line">                .reduce(<span class="string">""</span>,String::concat);<span class="comment">// 拆成字母后，拼接成一个新的字符串，相当于.reduce("",(String a ,String b)-&gt;a+b);</span></span><br><span class="line">        System.out.println(newstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>collect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; appleList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">appleList.stream().collect(Collectors.averagingInt(Apple::getWeight));<span class="comment">// 计算重量的平均值</span></span><br><span class="line">appleList.stream().map(Apple::getColor).collect(Collectors.joining());<span class="comment">// 连接字符串</span></span><br></pre></td></tr></table></figure><h2 id="创建流的方式"><a href="#创建流的方式" class="headerlink" title="创建流的方式"></a>创建流的方式</h2><p><strong>值创建流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt;  strstream=Stream.of(&quot;dasd&quot;,&quot;dsa&quot;,&quot;das&quot;);</span><br></pre></td></tr></table></figure><p><strong>数据创建流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] nums=&#123;&quot;qwe&quot;,&quot;ee&quot;,&quot;ds&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; aaa=Arrays.stream(nums);</span><br></pre></td></tr></table></figure><p><strong>文件创建流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Stream&lt;String&gt; lines=Files.lines(Paths.get(&quot;C:\\Users\\maruami\\Desktop\\readbook\\book.md&quot;), Charset.defaultCharset());</span><br><span class="line">    lines.forEach(System.out::println);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数生成流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;p&gt;Java8的新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。Steam API极大得简化了集合操作，Stream流配合Lambda表达式使用起来真是美滋滋，steam的另一个价值是创造性地支持并行处理。&lt;/p&gt;
&lt;p&gt;优点：性能高，灵活，表达清楚&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;api分为两大类，中间操作相当于流水线，能对流水线上的东西进行各种处理，不会消耗流；终端操作消耗流，不能再对流进行操作&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;中间操作(流水线)&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;过滤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;抽取流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;limit&lt;/td&gt;
&lt;td&gt;限制个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;skip&lt;/td&gt;
&lt;td&gt;跳过个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sorted&lt;/td&gt;
&lt;td&gt;排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;distinct&lt;/td&gt;
&lt;td&gt;去重&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flagmap&lt;/td&gt;
&lt;td&gt;合并到一起&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;终端操作(消耗流)&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;collect&lt;/td&gt;
&lt;td&gt;收集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;foreach&lt;/td&gt;
&lt;td&gt;遍历&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count&lt;/td&gt;
&lt;td&gt;计数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;anyMatch&lt;/td&gt;
&lt;td&gt;至少匹配1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allMatch&lt;/td&gt;
&lt;td&gt;匹配所有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;noneMatch&lt;/td&gt;
&lt;td&gt;没有元素匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;findAny&lt;/td&gt;
&lt;td&gt;返回流中任意元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduce&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Stream" scheme="https://masonnpe.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://masonnpe.github.io/2018/11/03/Java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://masonnpe.github.io/2018/11/03/Java/Lambda表达式/</id>
    <published>2018-11-03T08:01:39.948Z</published>
    <updated>2018-11-03T08:03:51.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），可以使代码变的更加简洁紧凑。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;代码块&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li>参数类型可省略，编译器可以自己推断</li><li>如果只有一个参数，圆括号可以省略</li><li>代码块如果只是一行代码，大括号也可以省略</li><li>如果代码块是一行，且是有结果的表达式，<code>return</code>可以省略</li></ul><p><strong>注意：</strong>事实上，把Lambda表达式可以看做是匿名内部类的一种简写方式。当然，前提是这个匿名内部类对应的必须是接口，而且接口中必须只有一个函数！Lambda表达式就是直接编写函数的：参数列表、代码体、返回值等信息。</p><a id="more"></a><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备一个集合</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">10</span>, <span class="number">5</span>, <span class="number">25</span>, -<span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">list.sort((i1,i2) -&gt; &#123; <span class="keyword">return</span> i1 - i2;&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//output [-15, 5, 10, 20, 25]</span></span><br></pre></td></tr></table></figure><p>还可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort((i1,i2) -&gt; i1 - i2);</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>Lambda表达式的实质其实还是匿名内部类，所以我们其实可以把Lambda表达式赋值给某个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;System.out.println(<span class="string">"hello lambda!"</span>);&#125;;</span><br></pre></td></tr></table></figure><h4 id="隐式final"><a href="#隐式final" class="headerlink" title="隐式final"></a>隐式final</h4><p>Lambda表达式的实质其实还是匿名内部类，而匿名内部类在访问外部局部变量时，要求变量必须声明为<code>final</code>。不过我们在使用Lambda表达式时无需声明<code>final</code>，因为Lambda底层会隐式的把变量设置为<code>final</code>，在后续的操作中，一定不能修改该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个局部变量</span></span><br><span class="line"><span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在Lambda表达式中使用局部变量num，num会被隐式声明为final，不能进行任何修改操作</span></span><br><span class="line">Runnable r = () -&gt; &#123;System.out.println(num);&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><ul><li>Lambda表达式是接口的匿名内部类的简写形式</li><li>接口必须满足：内部只有一个函数</li></ul><p>其实这样的接口，我们称为函数式接口，我们学过的<code>Runnable</code>、<code>Comparator</code>都是函数式接口的典型代表。但是在实践中，函数接口是非常脆弱的，只要有人在接口里添加多一个方法，那么这个接口就不是函数接口了，就会导致编译失败。Java 8提供了一个特殊的注解<code>@FunctionalInterface</code>来克服上面提到的脆弱性并且显示地表明函数接口。而且jdk8版本中，对很多已经存在的接口都添加了<code>@FunctionalInterface</code>注解，例如<code>Runnable</code>接口，另外，Jdk8默认提供了一些函数式接口供我们使用：</p><h3 id="Function类型接口"><a href="#Function类型接口" class="headerlink" title="Function类型接口"></a>Function类型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 接收一个参数T，返回一个结果R</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function代表的是有参数，有返回值的函数。还有很多类似的Function接口：</p><table><thead><tr><th style="text-align:left">接口名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BiFunction&lt;T,U,R&gt;</code></td><td>接收两个T和U类型的参数，并且返回R类型结果的函数</td></tr><tr><td style="text-align:left"><code>DoubleFunction&lt;R&gt;</code></td><td>接收double类型参数，并且返回R类型结果的函数</td></tr><tr><td style="text-align:left"><code>IntFunction&lt;R&gt;</code></td><td>接收int类型参数，并且返回R类型结果的函数</td></tr><tr><td style="text-align:left"><code>LongFunction&lt;R&gt;</code></td><td>接收long类型参数，并且返回R类型结果的函数</td></tr><tr><td style="text-align:left"><code>ToDoubleFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回double类型结果</td></tr><tr><td style="text-align:left"><code>ToIntFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回int类型结果</td></tr><tr><td style="text-align:left"><code>ToLongFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回long类型结果</td></tr><tr><td style="text-align:left"><code>DoubleToIntFunction</code></td><td>接收double类型参数，返回int类型结果</td></tr><tr><td style="text-align:left"><code>DoubleToLongFunction</code></td><td>接收double类型参数，返回long类型结果</td></tr></tbody></table><p>这些都是一类函数接口，在Function基础上衍生出的，要么明确了参数不确定返回结果，要么明确结果不知道参数类型，要么两者都知道。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 接收T类型参数，不返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具备类似的特征：那就是不返回任何结果。</p><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 接收T类型参数，返回boolean类型结果</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Predicate系列参数不固定，但是返回的一定是boolean类型。</p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 无需参数，返回一个T类型结果</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不接受任何参数，返回T类型结果。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得开发者可以将已经存在的方法作为变量来传递使用。方法引用可以和Lambda表达式配合使用。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>类名::静态方法名</td><td>类的静态方法的引用</td></tr><tr><td>类名::非静态方法名</td><td>类的非静态方法的引用</td></tr><tr><td>实例对象::非静态方法名</td><td>类的指定实例对象的非静态方法引用</td></tr><tr><td>类名::new</td><td>类的构造方法引用</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>首先我们编写一个集合工具类，提供一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用function将list集合中的每一个元素转换后形成新的集合返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 要转换的源集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 转换元素的方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 源集合的元素类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; 转换后的元素类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">convert</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; function)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.forEach(t -&gt; result.add(function.apply(t)));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法接收两个参数：</p><ul><li><code>List&lt;T&gt; list</code>：需要进行转换的集合</li><li><code>Function&lt;T,R&gt;</code>：函数接口，接收T类型，返回R类型。用这个函数接口对list中的元素T进行转换，变为R类型</li></ul><h4 id="类的静态方法引用"><a href="#类的静态方法引用" class="headerlink" title="类的静态方法引用"></a>类的静态方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>我们需要把这个集合中的元素转为十六进制保存，需要调用<code>Integer.toHexString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toUnsignedString0(i, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收一个 i 类型，返回一个<code>String</code>类型，可以用来构造一个<code>Function</code>的函数接口：</p><p>我们先按照Lambda原始写法，传入的Lambda表达式会被编译为<code>Function</code>接口，接口中通过<code>Integer.toHexString(i)</code>对原来集合的元素进行转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Lambda表达式实现</span></span><br><span class="line">List&lt;String&gt; hexList = CollectionUtil.convert(list, i -&gt; Integer.toHexString(i));</span><br><span class="line">System.out.println(hexList);<span class="comment">// [3e8, 7d0, bb8]</span></span><br></pre></td></tr></table></figure><p>上面的Lambda表达式代码块中，只有对<code>Integer.toHexString()</code>方法的引用，没有其它代码，因此我们可以直接把方法作为参数传递，由编译器帮我们处理，这就是静态方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的静态方法引用</span></span><br><span class="line">List&lt;String&gt; hexList = CollectionUtil.convert(list, Integer::toHexString);</span><br><span class="line">System.out.println(hexList);<span class="comment">// [3e8, 7d0, bb8]</span></span><br></pre></td></tr></table></figure><h4 id="类的非静态方法引用"><a href="#类的非静态方法引用" class="headerlink" title="类的非静态方法引用"></a>类的非静态方法引用</h4><p>接下来，我们把刚刚生成的<code>String</code>集合<code>hexList</code>中的元素都变成大写，需要借助于String类的toUpperCase()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toUpperCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次是非静态方法，不能用类名调用，需要用实例对象，因此与刚刚的实现有一些差别，我们接收集合中的每一个字符串<code>s</code>。但与上面不同然后<code>s</code>不是<code>toUpperCase()</code>的参数，而是调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Lambda表达式，接收String数据，调用toUpperCase()</span></span><br><span class="line">List&lt;String&gt; upperList = CollectionUtil.convert(hexList, s -&gt; s.toUpperCase());</span><br><span class="line">System.out.println(upperList);<span class="comment">// [3E8, 7D0, BB8]</span></span><br></pre></td></tr></table></figure><p>因为代码体只有对<code>toUpperCase()</code>的调用，所以可以把方法作为参数引用传递，依然可以简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的成员方法</span></span><br><span class="line">List&lt;String&gt; upperList = CollectionUtil.convert(hexList, String::toUpperCase);</span><br><span class="line">System.out.println(upperList);<span class="comment">// [3E8, 7D0, BB8]</span></span><br></pre></td></tr></table></figure><h4 id="指定实例的非静态方法引用"><a href="#指定实例的非静态方法引用" class="headerlink" title="指定实例的非静态方法引用"></a>指定实例的非静态方法引用</h4><p>下面一个需求是这样的，我们先定义一个数字<code>Integer num = 2000</code>，然后用这个数字和集合中的每个数字进行比较，比较的结果放入一个新的集合。比较对象，我们可以用<code>Integer</code>的<code>compareTo</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用Lambda实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个对象的成员方法</span></span><br><span class="line">Integer num = <span class="number">2000</span>;</span><br><span class="line">List&lt;Integer&gt; compareList = CollectionUtil.convert(list, i -&gt; num.compareTo(i));</span><br><span class="line">System.out.println(compareList);<span class="comment">// [1, 0, -1]</span></span><br></pre></td></tr></table></figure><p>与前面类似，这里Lambda的代码块中，依然只有对<code>num.compareTo(i)</code>的调用，所以可以简写。但是，需要注意的是，这次方法的调用者不是集合的元素，而是一个外部的局部变量<code>num</code>，因此不能使用 <code>Integer::compareTo</code>，因为这样是无法确定方法的调用者。要指定调用者，需要用 <code>对象::方法名</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个对象的成员方法</span></span><br><span class="line">Integer num = <span class="number">2000</span>;</span><br><span class="line">List&lt;Integer&gt; compareList = CollectionUtil.convert(list, num::compareTo);</span><br><span class="line">System.out.println(compareList);<span class="comment">// [1, 0, -1]</span></span><br></pre></td></tr></table></figure><h4 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h4><p>最后一个场景：把集合中的数字作为毫秒值，构建出<code>Date</code>对象并放入集合，这里我们就需要用到Date的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>   date   the milliseconds since January 1, 1970, 00:00:00 GMT.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     java.lang.System#currentTimeMillis()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">    fastTime = date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以接收集合中的每个元素，然后把元素作为<code>Date</code>的构造函数参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数值类型集合，转为Date类型</span></span><br><span class="line">List&lt;Date&gt; dateList = CollectionUtil.convert(list, i -&gt; <span class="keyword">new</span> Date(i));</span><br><span class="line"><span class="comment">// 这里遍历元素后需要打印，因此直接把println作为方法引用传递了</span></span><br><span class="line">dateList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的Lambda表达式实现方式，代码体只有<code>new Date()</code>一行代码，因此也可以采用方法引用进行简写。但问题是，构造函数没有名称，我们只能用<code>new</code>关键字来代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">List&lt;Date&gt; dateList = CollectionUtil.convert(list, Date::<span class="keyword">new</span>);</span><br><span class="line">dateList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>注意两点：</p><ul><li>上面代码中的System.out::println 其实是 指定对象System.out的非静态方法println的引用</li><li>如果构造函数有多个，可能无法区分导致传递失败</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;p&gt;Lambda 表达式，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），可以使代码变的更加简洁紧凑。&lt;/p&gt;
&lt;h3 id=&quot;基本语法：&quot;&gt;&lt;a href=&quot;#基本语法：&quot; class=&quot;headerlink&quot; title=&quot;基本语法：&quot;&gt;&lt;/a&gt;基本语法：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(参数列表) -&amp;gt; &amp;#123;代码块&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数类型可省略，编译器可以自己推断&lt;/li&gt;
&lt;li&gt;如果只有一个参数，圆括号可以省略&lt;/li&gt;
&lt;li&gt;代码块如果只是一行代码，大括号也可以省略&lt;/li&gt;
&lt;li&gt;如果代码块是一行，且是有结果的表达式，&lt;code&gt;return&lt;/code&gt;可以省略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;事实上，把Lambda表达式可以看做是匿名内部类的一种简写方式。当然，前提是这个匿名内部类对应的必须是接口，而且接口中必须只有一个函数！Lambda表达式就是直接编写函数的：参数列表、代码体、返回值等信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Lambda" scheme="https://masonnpe.github.io/tags/Lambda/"/>
    
  </entry>
  
</feed>
