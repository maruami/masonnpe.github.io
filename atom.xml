<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Masonnpe&#39;s Blog</title>
  
  <subtitle>愿所有的坚持终不被辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://masonnpe.github.io/"/>
  <updated>2018-12-14T12:48:27.048Z</updated>
  <id>https://masonnpe.github.io/</id>
  
  <author>
    <name>Masonnpe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL性能优化Explain</title>
    <link href="https://masonnpe.github.io/2018/12/14/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96Explain/"/>
    <id>https://masonnpe.github.io/2018/12/14/数据库/SQL性能优化Explain/</id>
    <published>2018-12-14T12:19:55.415Z</published>
    <updated>2018-12-14T12:48:27.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化。EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>建立两个测试用的表并添加相应的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age`  INT(11)              DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br><span class="line"></span><br><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</span><br><span class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-输出含义"><a href="#EXPLAIN-输出含义" class="headerlink" title="EXPLAIN 输出含义"></a>EXPLAIN 输出含义</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中内层的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul><a id="more"></a><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p><ul><li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li><li><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2</span><br></pre></td></tr></table></figure><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. 例如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id</span><br></pre></td></tr></table></figure><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5</span><br></pre></td></tr></table></figure><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info WHERE id BETWEEN 2 AND 8</span><br></pre></td></tr></table></figure><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info</span><br></pre></td></tr></table></figure><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 <code>Using index</code>.</p><ul><li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20</span><br></pre></td></tr></table></figure><h4 id="type-类型的性能比较"><a href="#type-类型的性能比较" class="headerlink" title="type 类型的性能比较"></a>type 类型的性能比较</h4><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li>字符串<ul><li>char(n): n 字节长度</li><li>varchar(n): 如果是 utf8 编码, 则是 3 <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em> n + 2 字节.</li></ul></li><li>数值类型:<ul><li>TINYINT: 1字节</li><li>SMALLINT: 2字节</li><li>MEDIUMINT: 3字节</li><li>INT: 4字节</li><li>BIGINT: 8字节</li></ul></li><li>时间类型<ul><li>DATE: 3字节</li><li>TIMESTAMP: 4字节</li><li>DATETIME: 8字节</li></ul></li><li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</li></ul><p>我们来举两个简单的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos;</span><br></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; </span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>哪个字段或常数与 key 一起被使用</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>表示此查询条件所过滤的数据的百分比</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li></ul><p>例如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name</span><br></pre></td></tr></table></figure><p>我们的索引是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code>.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name</span><br></pre></td></tr></table></figure><ul><li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MySQL 提供了一个 EXPLAIN 命令, 它可以对 &lt;code&gt;SELECT&lt;/code&gt; 语句进行分析, 并输出 &lt;code&gt;SELECT&lt;/code&gt; 执行的详细信息, 以供开发人员针对性优化。EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;建立两个测试用的表并添加相应的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `user_info` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` VARCHAR(50) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `age`  INT(11)              DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `name_index` (`name`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ENGINE = InnoDB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DEFAULT CHARSET = utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `order_info` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `user_id`      BIGINT(20)           DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `product_name` VARCHAR(50) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `productor`    VARCHAR(30)          DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ENGINE = InnoDB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DEFAULT CHARSET = utf8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;EXPLAIN-输出含义&quot;&gt;&lt;a href=&quot;#EXPLAIN-输出含义&quot; class=&quot;headerlink&quot; title=&quot;EXPLAIN 输出含义&quot;&gt;&lt;/a&gt;EXPLAIN 输出含义&lt;/h2&gt;&lt;h3 id=&quot;id&quot;&gt;&lt;a href=&quot;#id&quot; class=&quot;headerlink&quot; title=&quot;id&quot;&gt;&lt;/a&gt;id&lt;/h3&gt;&lt;p&gt;SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.&lt;/p&gt;
&lt;h3 id=&quot;select-type&quot;&gt;&lt;a href=&quot;#select-type&quot; class=&quot;headerlink&quot; title=&quot;select_type&quot;&gt;&lt;/a&gt;select_type&lt;/h3&gt;&lt;p&gt;&lt;code&gt;select_type&lt;/code&gt; 表示了查询的类型, 它的常用取值有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIMPLE, 表示此查询不包含 UNION 查询或子查询&lt;/li&gt;
&lt;li&gt;PRIMARY, 表示此查询是最外层的查询&lt;/li&gt;
&lt;li&gt;UNION, 表示此查询是 UNION 的第二或随后的查询&lt;/li&gt;
&lt;li&gt;DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询&lt;/li&gt;
&lt;li&gt;UNION RESULT, UNION 的结果&lt;/li&gt;
&lt;li&gt;SUBQUERY, 子查询中的第一个 SELECT&lt;/li&gt;
&lt;li&gt;DEPENDENT SUBQUERY: 子查询中内层的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://masonnpe.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="https://masonnpe.github.io/2018/11/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>https://masonnpe.github.io/2018/11/27/数据库/数据库索引/</id>
    <published>2018-11-27T15:35:49.421Z</published>
    <updated>2018-11-27T15:42:57.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>索引是在存储引擎层实现的，不同的存储引擎具有不同的索引类型和实现方式</p><p><strong>B+Tree</strong></p><p>B+Tree是一种专门针对磁盘存储而优化的N叉排序树，以树的节点为单位存储在磁盘中，从根开始查找所需数据所在的节点编号和磁盘位置，将其加载到内存中然后继续查找，直到找到所需的数据。</p><p>B+Tree是大多数MySQL存储引擎默认的索引类型，是基于B-Tree和叶子节点顺序访问指针实现的，它所有叶子节点位于同一层，并且通过顺序访问指针来提高区间查询的性能。</p><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找对应的数据</p><p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性</p><p><img src="http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_B-Tree.PNG" alt="B+Tree"></p><a id="more"></a><p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" rel="noopener">B+Tree插入删除查找演示地址（需翻墙）</a></p><p>而许多NoSQL使用LSM树作为主要的数据结构，在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远超B+Tree。</p><p>数据库在做查询时IO消耗比较大，B+Tree每到一层就发生一次IO操作，为了减少IO操作，提高查询效率，要让这棵树尽可能的低</p><p>利于计算机的预读特性，内存和磁盘以片为单位读取数据，将连续的数据放到同一片里，读取会更快</p><p>红黑树也可以用来实现索引，但是树高，所以IO次数多</p><p><strong>Hash</strong></p><p>基于Hash表，查找速度很快，一般情况下查找的时间复杂度O(1)，仅需要一次查找就能定位数据。缺点：</p><ul><li>失去有序性，无法用于排序和分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>在InnoDB引擎中，数据库自优化生成Hash索引</p><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，数据库根据查询情况，对使用频繁的索引自优化生成Hash索引</p><p><strong>Fulltext</strong></p><p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等，查找条件使用 MATCH AGAINST，而不是普通的 WHERE。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引</p><p><strong>R-Tree</strong></p><p>空间数据索引,可以用于地理数据存储。空间数据索引会从所有维度来查找数据，可以有效地使用任意维度来进行组合查询，必须使用 GIS 相关的函数来维护数据</p><h3 id="聚集索引-·-非聚集索引"><a href="#聚集索引-·-非聚集索引" class="headerlink" title="聚集索引 · 非聚集索引"></a>聚集索引 · 非聚集索引</h3><p><strong>聚集索引</strong></p><p>索引的键值逻辑顺序决定数据行的物理存储顺序</p><p>InnoDB主索引的叶子节点 data 域记录着完整的数据记录，因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343758042_8526.png" alt="主索引"></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找</p><p><img src="http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343758434_9462.png" alt="辅助索引"></p><p>所以<strong>不要使用过长的字段作为主键</strong>，过长的主索引会令辅助索引变得过大</p><p>推荐使用自增字段作为主键，否则非自增的主键会造成在插入新记录时，索引会为了维持B+Tree的特性而频繁的分裂调整</p><p><strong>非聚集索引</strong></p><p>索引的键值逻辑顺序，但数据行的物理存储地址不一定顺序</p><p>MyISAM叶子节点存放的是数据的物理地址而不是数据本身。在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用</p><p><img src="http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343757655_1008.png" alt=""></p><h3 id="单一索引-·-复合索引"><a href="#单一索引-·-复合索引" class="headerlink" title="单一索引 · 复合索引"></a>单一索引 · 复合索引</h3><p><strong>单一索引</strong></p><p>新建索引的语句只实施在一列上，<strong>索引要建在数据区分度高的列上</strong>，像sex这种区分度低的就不需要单独建索引</p><p><strong>复合索引</strong></p><p>可以指定多个列作为索引列，组成复合索引。索引列<strong>数据区分度高</strong>的放在前面</p><ul><li>按照where条件建索引，索引包含所有需要查询的字段的值</li><li>有复合索引unionindex(column1,column2)，就没有必要再建index(column1)</li><li>复合索引的索引列不要太多</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>减少需要扫描的数据行数，加快数据的查询速度</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>随着数据量的增加，建立和维护索引的时间和空间也会增加</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。会增加数据库写操作的成本，降低表更新的速度</li><li>会增加查询优化器的选择时间</li></ul><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><p><strong>在哪儿建索引</strong></p><ul><li>经常需要搜索的列上，可以加快搜索的速度</li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>多表join关联列</li><li>select update delete where 的列</li><li>orderby groupby distinct中的字段</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li><li>选择索引列的顺序<ul><li>区分度最高的放最左侧</li><li>字段长度小的列放左</li><li>最频繁使用的列放左</li></ul></li></ul><p><strong>不该在哪儿建索引</strong></p><ul><li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些只有数据值区分区很小的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>数据类型为text, image和bit数据类型的列不应该增加索引</li><li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p><strong>索引列是表达式的一部分或函数的参数不能使用索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_user <span class="keyword">where</span> <span class="keyword">id</span>+<span class="number">1</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_user <span class="keyword">having</span> <span class="keyword">max</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><p><strong>复合索引最左前缀不能使用索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_id_username <span class="keyword">on</span> tbl_user(<span class="keyword">id</span>,username);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_user <span class="keyword">where</span> username=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure><p><strong>负向查询不能使用索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><strong>前导模糊查询不能使用索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%zhangsan'</span></span><br></pre></td></tr></table></figure><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>局部性原理与磁盘预读：由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。</strong>一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>通过MySQL工具explain+查询语句</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h2&gt;&lt;p&gt;索引是在存储引擎层实现的，不同的存储引擎具有不同的索引类型和实现方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+Tree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B+Tree是一种专门针对磁盘存储而优化的N叉排序树，以树的节点为单位存储在磁盘中，从根开始查找所需数据所在的节点编号和磁盘位置，将其加载到内存中然后继续查找，直到找到所需的数据。&lt;/p&gt;
&lt;p&gt;B+Tree是大多数MySQL存储引擎默认的索引类型，是基于B-Tree和叶子节点顺序访问指针实现的，它所有叶子节点位于同一层，并且通过顺序访问指针来提高区间查询的性能。&lt;/p&gt;
&lt;p&gt;进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找对应的数据&lt;/p&gt;
&lt;p&gt;插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_B-Tree.PNG&quot; alt=&quot;B+Tree&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://masonnpe.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="https://masonnpe.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>transient</title>
    <link href="https://masonnpe.github.io/2018/11/27/Java/transient/"/>
    <id>https://masonnpe.github.io/2018/11/27/Java/transient/</id>
    <published>2018-11-27T15:27:24.003Z</published>
    <updated>2018-11-27T15:27:33.451Z</updated>
    
    <content type="html"><![CDATA[<p>对于实现<code>Serializable</code>接口的类，属性前添加关键字<code>transient</code>，序列化对象的时候，这个属性就不会被序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>要使<code>transient</code>生效，类需要实现<code>Serializable</code>接口</li><li><code>transient</code>关键字只能修饰变量，不能修饰方法和类</li><li>静态变量不管是否被<code>transient</code>修饰，均不能被序列化，反序列化后对象中<code>static</code>型变量的值为当前JVM中对应类中<code>static</code>变量的值</li></ul><a id="more"></a><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientDemo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5818461504980738394L</span>;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> String password;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> String staticPassword;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">static</span> String transientAndStaticPassword;</span><br><span class="line"><span class="comment">// get/set省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      TransientDemo transientDemo = <span class="keyword">new</span> TransientDemo();</span><br><span class="line">      transientDemo.setName(<span class="string">"root"</span>);</span><br><span class="line">      transientDemo.setPassword(<span class="string">"*********"</span>);</span><br><span class="line">      transientDemo.setStaticPassword(<span class="string">"*********"</span>);</span><br><span class="line">      transientDemo.setTransientAndStaticPassword(<span class="string">"*********"</span>);</span><br><span class="line"></span><br><span class="line">      ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">          oos.writeObject(transientDemo);</span><br><span class="line">          b = baos.toByteArray();</span><br><span class="line">          System.err.println(<span class="string">"before name="</span> + transientDemo.getName());</span><br><span class="line">          System.err.println(<span class="string">"before getPassword="</span> + transientDemo.getPassword());</span><br><span class="line">          System.err.println(<span class="string">"before getStaticPassword="</span> + transientDemo.getStaticPassword());</span><br><span class="line">          System.err.println(<span class="string">"before getTransientAndStaticPassword="</span> + transientDemo.getTransientAndStaticPassword());</span><br><span class="line">          TransientDemo.staticPassword = <span class="string">"我不是真的"</span>;</span><br><span class="line">          TransientDemo.transientAndStaticPassword = <span class="string">"我不是真的"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(b);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">          TransientDemo demo = (TransientDemo) ois.readObject();</span><br><span class="line">          System.err.println(<span class="string">"after name="</span> + demo.getName());</span><br><span class="line">          System.err.println(<span class="string">"after getPassword="</span> + demo.getPassword());</span><br><span class="line">          System.err.println(<span class="string">"after getStaticPassword="</span> + demo.getStaticPassword());</span><br><span class="line">          System.err.println(<span class="string">"after getTransientAndStaticPassword="</span> + demo.getTransientAndStaticPassword());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before name=root</span><br><span class="line">before getPassword=*********</span><br><span class="line">before getStaticPassword=*********</span><br><span class="line">before getTransientAndStaticPassword=*********</span><br><span class="line">after name=root</span><br><span class="line">after getPassword=*********</span><br><span class="line">after getStaticPassword=我不是真的</span><br><span class="line">after getTransientAndStaticPassword=我不是真的</span><br></pre></td></tr></table></figure><h2 id="自定义序列化方式"><a href="#自定义序列化方式" class="headerlink" title="自定义序列化方式"></a>自定义序列化方式</h2><p>被<code>transient</code>修饰的属性可以通过<code>writeObject()</code>方法，自定义属性的序列化方式</p><p>参考JDK1.8 <code>ArrayList</code>自定义了对<code>elementData</code>的序列化与反序列化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);    <span class="comment">//只序列化被使用的数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject(); <span class="comment">//反序列化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p><code>Externalizable</code>和<code>Serializable</code>相比，<code>Externalizable</code>是<code>Serializable</code>接口的子类</p><ul><li><p><code>Serializable</code>序列化时不会调用默认的构造器，而<code>Externalizable</code>序列化时会调用默认构造器的，否则会报<code>java.io.InvalidClassException</code></p></li><li><p>实现了<code>Serializable</code>接口的类，默认会序列化对象的所有属性（包括<code>private</code>属性和引用的对象）</p><p><code>Externalizable</code>默认不序列化对象的任何属性，通过重写<code>writeExternal()</code>和<code>readExternal()</code>方法指定序列化哪些属性 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于实现&lt;code&gt;Serializable&lt;/code&gt;接口的类，属性前添加关键字&lt;code&gt;transient&lt;/code&gt;，序列化对象的时候，这个属性就不会被序列化&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Object[] elementData;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;注意点&quot;&gt;&lt;a href=&quot;#注意点&quot; class=&quot;headerlink&quot; title=&quot;注意点&quot;&gt;&lt;/a&gt;注意点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;要使&lt;code&gt;transient&lt;/code&gt;生效，类需要实现&lt;code&gt;Serializable&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transient&lt;/code&gt;关键字只能修饰变量，不能修饰方法和类&lt;/li&gt;
&lt;li&gt;静态变量不管是否被&lt;code&gt;transient&lt;/code&gt;修饰，均不能被序列化，反序列化后对象中&lt;code&gt;static&lt;/code&gt;型变量的值为当前JVM中对应类中&lt;code&gt;static&lt;/code&gt;变量的值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="transient" scheme="https://masonnpe.github.io/tags/transient/"/>
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="https://masonnpe.github.io/2018/11/27/Java/static/"/>
    <id>https://masonnpe.github.io/2018/11/27/Java/static/</id>
    <published>2018-11-27T15:10:29.733Z</published>
    <updated>2018-11-27T15:10:53.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>静态变量</strong></p><ul><li>静态变量属于类，可以直接通过类名来访问它</li><li>类的实例共享静态变量</li></ul><p><strong>静态方法</strong></p><ul><li>静态方法必须有实现</li><li>只能访问所属类的静态变量和静态方法，且方法中不能有 this 和 super 关键字</li></ul><a id="more"></a><p><strong>静态语句块</strong></p><ul><li>静态语句块只会在类初始化时运行一次</li></ul><p><strong>静态内部类</strong></p><ul><li>非静态内部类依赖于外部类的实例，而静态内部类不需要</li><li>静态内部类不能访问外部类的非静态的变量和方法</li></ul><p><strong>静态导包</strong></p><ul><li>在使用静态变量和方法时不用再指明类名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.Executors.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">newCachedThreadPool();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;静态变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量属于类，可以直接通过类名来访问它&lt;/li&gt;
&lt;li&gt;类的实例共享静态变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态方法必须有实现&lt;/li&gt;
&lt;li&gt;只能访问所属类的静态变量和静态方法，且方法中不能有 this 和 super 关键字&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="static" scheme="https://masonnpe.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="https://masonnpe.github.io/2018/11/27/Java/Set/"/>
    <id>https://masonnpe.github.io/2018/11/27/Java/Set/</id>
    <published>2018-11-27T15:05:14.373Z</published>
    <updated>2018-11-27T15:07:47.324Z</updated>
    
    <content type="html"><![CDATA[<p>特点：不会存储重复的元素</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>Object的hashCode方法的话，hashCode会返回每个对象特有的序号（Java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。</p><p>如果想要让两个不同的Object对象视为相等的，就必须重写类的hashCode方法和equals方法，同时也需要两个不同对象比较equals方法会返回true</p><p>HashSet和ArrayList都有判断元素是否相同的方法</p><ul><li><p>ArrayList使用boolean contains(Object o)–&gt;indexOf(Object o)–&gt;equals</p></li><li><p>HashSet使用hashCode和equals方法</p><ul><li>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</li><li>判断两个元素是否相同，先判断元素的hashCode值是否一致，如果相同才会去判断equals方法</li></ul></li></ul><a id="more"></a><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>基于红黑树实现，不能重复存储元素，还能实现排序</p><p>有两种自定义排序规则的方法</p><ul><li>让存入的元素自身具有比较性<ul><li>实现Comparable接口，重写compareTo(Object o)方法</li></ul></li><li>给TreeSet指定排序规则<ul><li>定义一个类实现接口Comparator，重写compare(Object o1, Object o2）方法，该接口的子类实例对象作为参数传递给TreeMap集合的构造方法</li><li>如果Comparable和Comparator同时存在，优先Comparator</li></ul></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>会保存与元素插入的顺序</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到array，就要想到下标</p><p>看到link，就要想到first，last</p><p>看到hash，就要想到hashCode,equals</p><p>看到tree，就要想到两个接口。Comparable，Comparator</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：不会存储重复的元素&lt;/p&gt;
&lt;h2 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;HashSet&lt;/h2&gt;&lt;p&gt;Object的hashCode方法的话，hashCode会返回每个对象特有的序号（Java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。&lt;/p&gt;
&lt;p&gt;如果想要让两个不同的Object对象视为相等的，就必须重写类的hashCode方法和equals方法，同时也需要两个不同对象比较equals方法会返回true&lt;/p&gt;
&lt;p&gt;HashSet和ArrayList都有判断元素是否相同的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ArrayList使用boolean contains(Object o)–&amp;gt;indexOf(Object o)–&amp;gt;equals&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashSet使用hashCode和equals方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型&lt;/li&gt;
&lt;li&gt;判断两个元素是否相同，先判断元素的hashCode值是否一致，如果相同才会去判断equals方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="Set" scheme="https://masonnpe.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>算法题解题思路</title>
    <link href="https://masonnpe.github.io/2018/11/26/Algorithm/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <id>https://masonnpe.github.io/2018/11/26/Algorithm/算法题解题思路/</id>
    <published>2018-11-26T15:58:50.870Z</published>
    <updated>2018-11-26T15:59:56.475Z</updated>
    
    <content type="html"><![CDATA[<p>算法题套路</p><ol><li>如果是数据排序方面的题，那基本上是和二分查找有关系的。</li><li>如果是在一个无序数组上的搜索或者统计，基本上来说需要动用 O(1) 时间复杂度的 hash 数据结构。</li><li>在一堆无序的数据中找 top n 的算法，基本上来说，就是使用最大堆或是最小堆的数据结构。</li><li>如果是穷举答案相关的题（如八皇后、二叉树等），基本上来说，需要使用深度优先、广度优先或是回溯等递归的思路。</li><li>动态规划要重点准备一下，这样的题很多，如最大和子数组、买卖股票、背包问题、爬楼梯、改字符……这里有一个 Top 20 的动态规划题的列表 。</li><li>一些经典的数据结构算法也要看一下，比如，二叉树、链表和数组上的经典算法，LRU 算法，Tier 树，字符串子串匹配，回文等，这些常见的题都是经常会被考到的。</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法题套路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是数据排序方面的题，那基本上是和二分查找有关系的。&lt;/li&gt;
&lt;li&gt;如果是在一个无序数组上的搜索或者统计，基本上来说需要动用 O(1) 时间复杂度的 hash 数据结构。&lt;/li&gt;
&lt;li&gt;在一堆无序的数据中找 top n 的算法，基本上来说，就是使用最大堆或是最小堆的数据结构。&lt;/li&gt;
&lt;li&gt;如果是穷举答案相关的题（如八皇后、二叉树等），基本上来说，需要使用深度优先、广度优先或是回溯等递归的思路。&lt;/li&gt;
&lt;li&gt;动态规划要重点准备一下，这样的题很多，如最大和子数组、买卖股票、背包问题、爬楼梯、改字符……这里有一个 Top 20 的动态规划题的列表 。&lt;/li&gt;
&lt;li&gt;一些经典的数据结构算法也要看一下，比如，二叉树、链表和数组上的经典算法，LRU 算法，Tier 树，字符串子串匹配，回文等，这些常见的题都是经常会被考到的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://masonnpe.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://masonnpe.github.io/2018/11/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS/"/>
    <id>https://masonnpe.github.io/2018/11/26/并发编程/CAS/</id>
    <published>2018-11-26T14:44:10.062Z</published>
    <updated>2018-11-26T14:52:58.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。如果出现冲突就重试当前操作直到没有冲突为止。</p><a id="more"></a><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：<strong>V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值</strong>。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程</p><blockquote><p>Synchronized VS CAS</p><p>1.5前的Synchronized在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题</p><p>CAS并不是武断的间线程挂起，当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作</p></blockquote><h2 id="CAS的应用场景"><a href="#CAS的应用场景" class="headerlink" title="CAS的应用场景"></a>CAS的应用场景</h2><p>在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现。</p><h2 id="CAS与对象创建"><a href="#CAS与对象创建" class="headerlink" title="CAS与对象创建"></a>CAS与对象创建</h2><p>那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的。即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性。</p><h2 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h2><p><strong>1. ABA问题</strong><br>因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。JDK1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题。它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题，例如下面的代码分别用AtomicInteger和AtomicStampedReference来对初始值为100的原子整型变量进行更新，AtomicInteger会成功执行CAS操作，而加上版本戳的AtomicStampedReference对于ABA问题会执行CAS失败。</p><p><strong>2. 自旋时间过长</strong></p><p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。</p><p><strong>3. 只能保证一个共享变量的原子操作</strong></p><p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h2&gt;&lt;p&gt;使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。如果出现冲突就重试当前操作直到没有冲突为止。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://masonnpe.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CAS" scheme="https://masonnpe.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="https://masonnpe.github.io/2018/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://masonnpe.github.io/2018/11/25/数据库/MySQL主从复制/</id>
    <published>2018-11-25T14:47:52.983Z</published>
    <updated>2018-12-14T12:18:58.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h2><p><img src="http://ws4.sinaimg.cn/large/007iUdjSgy1fy6jgnueisj30pz0k6774.jpg" alt="image"></p><a id="more"></a><p>主库将增删改操作写binlog日志，从库连接到主库之后有一个IO线程，将主库的binlog日志拷贝到本地，写入到一个中继日志中，接着从库中有一个SQL线程会从中继日志读取binlog日志，并执行binlog日志中的内容，也就是在本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。这里有一个非常重要的点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以MySQL在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。</p><p>半同步复制（semi-sync复制），指的就是主库写入binlog日志之后，就会立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。</p><p>并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p><h2 id="MySQL主从同步延时"><a href="#MySQL主从同步延时" class="headerlink" title="MySQL主从同步延时"></a>MySQL主从同步延时</h2><p> 一般在读远远多于写的场景下来用这个MySQL主从同步，而且读的时候一般对数据时效性要求没那么高。主从同步延时问题，会导致一些线上的bug难以发现。可以通过show status，Seconds_Behind_Master，看到从库复制主库的数据落后了多少ms。</p><p>虽然可以用MySQL的并行复制，但是那是库级别的并行，时候作用不是很大。所以对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证可以读到数据。也可以重写业务代码比如第二句SQL不依赖第一句SQL，就直接更新不查询，如果依赖就先读判断结果是否为空，如果为空就报错下次重试。</p><h2 id="实现MySQL的读写分离"><a href="#实现MySQL的读写分离" class="headerlink" title="实现MySQL的读写分离"></a>实现MySQL的读写分离</h2><p>基于主从复制架构，简单来说就是搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制原理&quot;&gt;&lt;/a&gt;MySQL主从复制原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ws4.sinaimg.cn/large/007iUdjSgy1fy6jgnueisj30pz0k6774.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://masonnpe.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>MyBatis缓存</title>
    <link href="https://masonnpe.github.io/2018/11/25/MyBatis/MyBatis%E7%BC%93%E5%AD%98/"/>
    <id>https://masonnpe.github.io/2018/11/25/MyBatis/MyBatis缓存/</id>
    <published>2018-11-25T09:57:09.299Z</published>
    <updated>2018-11-25T15:20:50.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。个人在业务开发中也处理过一些由于MyBatis缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理MyBatis缓存机制。<br>本次分析中涉及到的代码和数据库表均放在GitHub上，地址： <a href="https://github.com/kailuncen/mybatis-cache-demo" target="_blank" rel="noopener">mybatis-cache-demo</a> 。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>本文按照以下顺序展开。</p><ul><li>一级缓存介绍及相关配置。</li><li>一级缓存工作流程及源码分析。</li><li>一级缓存总结。</li><li>二级缓存介绍及相关配置。</li><li>二级缓存源码分析。</li><li>二级缓存总结。</li><li>全文总结。</li></ul><a id="more"></a><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><h4 id="一级缓存介绍"><a href="#一级缓存介绍" class="headerlink" title="一级缓存介绍"></a>一级缓存介绍</h4><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-29-47.jpg" alt="img"><br>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。具体实现类的类关系图如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-23-16-13-29.jpg" alt="img"></p><h4 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h4><p>我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，SESSION或者STATEMENT，默认是SESSION级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是STATEMENT级别，可以理解为缓存只对当前执行的这一个Statement有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="一级缓存实验"><a href="#一级缓存实验" class="headerlink" title="一级缓存实验"></a>一级缓存实验</h4><p>接下来通过实验，了解MyBatis一级缓存的效果，每个单元测试后都请恢复被修改的数据。<br>首先是创建示例表student，创建对应的POJO类和增改的方法，具体可以在entity包和mapper包中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(200) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `age` tinyint(3) unsigned DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;</span><br></pre></td></tr></table></figure><p>在以下实验中，id为1的学生名称是凯伦。</p><h5 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h5><p>开启一级缓存，范围为会话级别，调用三次getStudentById，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void getStudentById() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = factory.openSession(true); // 自动提交事务</span><br><span class="line">        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(studentMapper.getStudentById(1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-30-06.jpg" alt="img"><br>我们可以看到，只有第一次真正查询了数据库，后续的查询使用了一级缓存。</p><h5 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h5><p>增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addStudent() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = factory.openSession(true); // 自动提交事务</span><br><span class="line">        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(&quot;增加了&quot; + studentMapper.addStudent(buildStudent()) + &quot;个学生&quot;);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(1));</span><br><span class="line">        sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-30-25.jpg" alt="img"><br>我们可以看到，在修改操作后执行的相同查询，查询了数据库，<strong>一级缓存失效</strong>。</p><h5 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h5><p>开启两个SqlSession，在sqlSession1中查询数据，使一级缓存生效，在sqlSession2中更新数据库，验证一级缓存只在数据库会话内部共享。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testLocalCacheScope() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(true); </span><br><span class="line"></span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(&quot;studentMapper2更新了&quot; + studentMapper2.updateStudentName(&quot;小岑&quot;,1) + &quot;个学生的数据&quot;);</span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentById(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-30-44.jpg" alt="img"><br>sqlSession2更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。</p><h4 id="一级缓存工作流程-amp-源码分析"><a href="#一级缓存工作流程-amp-源码分析" class="headerlink" title="一级缓存工作流程&amp;源码分析"></a>一级缓存工作流程&amp;源码分析</h4><p>那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下。</p><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>一级缓存执行的时序图，如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-31-11.png" alt="img"></p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>接下来将对MyBatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助。<br><strong>SqlSession</strong>： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是DefaultSqlSession。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-31-26.jpg" alt="img"></p><p><strong>Executor</strong>： SqlSession向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-31-47.jpg" alt="img"></p><p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-32-09.jpg" alt="img"></p><p>在一级缓存的源码分析中，主要学习BaseExecutor的内部实现。<br><strong>BaseExecutor</strong>： BaseExecutor是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;</span><br><span class="line">protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException;</span><br><span class="line">protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;</span><br><span class="line">protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException;</span><br></pre></td></tr></table></figure><p>在一级缓存的介绍中提到对Local Cache的查询和写入是在Executor内部完成的。在阅读BaseExecutor的代码后发现Local Cache是BaseExecutor内部的一个成员变量，如下代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseExecutor implements Executor &#123;</span><br><span class="line">protected ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">protected PerpetualCache localCache;</span><br></pre></td></tr></table></figure><p><strong>Cache</strong>： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-32-35.jpg" alt="img"><br>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-23-16-33-35.jpg" alt="img"><br>BaseExecutor成员变量之一的PerpetualCache，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class PerpetualCache implements Cache &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();</span><br></pre></td></tr></table></figure><p>在阅读相关核心类代码后，从源代码层面对一级缓存工作中涉及到的相关代码，出于篇幅的考虑，对源码做适当删减，读者朋友可以结合本文，后续进行更详细的学习。<br>为执行和数据库的交互，首先需要初始化SqlSession，通过DefaultSqlSessionFactory开启SqlSession：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    ............</span><br><span class="line">    final Executor executor = configuration.newExecutor(tx, execType);     </span><br><span class="line">    return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化SqlSesion时，会使用Configuration类创建一个全新的Executor，作为DefaultSqlSession构造函数的参数，创建Executor代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    // 尤其可以注意这里，如果二级缓存开关开启的话，是使用CahingExecutor装饰BaseExecutor的子类</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);                      </span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSession创建完毕后，根据Statment的不同类型，会进入SqlSession的不同方法中，如果是Select语句的话，最后会执行到SqlSession的selectList，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSession把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入BaseExecutor的query方法。代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CacheKey cacheKey = new CacheKey();</span><br><span class="line">cacheKey.update(ms.getId());</span><br><span class="line">cacheKey.update(rowBounds.getOffset());</span><br><span class="line">cacheKey.update(rowBounds.getLimit());</span><br><span class="line">cacheKey.update(boundSql.getSql());</span><br><span class="line">//后面是update了sql中带的参数</span><br><span class="line">cacheKey.update(value);</span><br></pre></td></tr></table></figure><p>在上述的代码中，将MappedStatement的Id、sql的offset、Sql的limit、Sql本身以及Sql中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_MULTIPLYER = 37;</span><br><span class="line">private static final int DEFAULT_HASHCODE = 17;</span><br><span class="line"></span><br><span class="line">private int multiplier;</span><br><span class="line">private int hashcode;</span><br><span class="line">private long checksum;</span><br><span class="line">private int count;</span><br><span class="line">private List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">public CacheKey() &#123;</span><br><span class="line">    this.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    this.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    this.count = 0;</span><br><span class="line">    this.updateList = new ArrayList&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是成员变量和构造函数，有一个初始的hachcode和乘数，同时维护了一个内部的updatelist。在CacheKey的update方法中，会进行一个hashcode和checksum的计算，同时把传入的参数添加进updatelist中。如下代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void update(Object object) &#123;</span><br><span class="line">    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); </span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时重写了CacheKey的equals方法，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    .............</span><br><span class="line">    for (int i = 0; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      if (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除去hashcode，checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL。</p><blockquote><p>Statement Id + Offset + Limmit + Sql + Params</p></blockquote><p>BaseExecutor的query方法继续往下走，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">if (list != null) &#123;</span><br><span class="line">    // 这个主要是处理存储过程用的。</span><br><span class="line">    handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。<br>在query方法执行的最后，会判断一级缓存级别是否是STATEMENT级别，如果是的话，就清空缓存，这也就是STATEMENT级别的一级缓存无法共享localCache的原因。代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码分析的最后，我们确认一下，如果是insert/delete/update方法，缓存就会刷新的原因。<br>SqlSession的insert方法和delete方法，都会统一走update的流程，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int insert(String statement, Object parameter) &#123;</span><br><span class="line">    return update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">   @Override</span><br><span class="line">  public int delete(String statement) &#123;</span><br><span class="line">    return update(statement, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update方法也是委托给了Executor执行。BaseExecutor的执行方法如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">      throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    return doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行update前都会清空localCache。</p><p>至此，一级缓存的工作流程讲解以及源码分析完毕。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>MyBatis一级缓存的生命周期和SqlSession一致。</li><li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li><li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li></ol><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><h4 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h4><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-33-42.png" alt="img"></p><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。<br>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><h4 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h4><p>要正确的使用二级缓存，需完成如下配置的。</p><ol><li><p>在MyBatis的配置文件中开启二级缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>在MyBatis的映射XML中配置cache或者 cache-ref 。</p></li></ol><p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure><ul><li>type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。</li><li>eviction： 定义回收的策略，常见的有FIFO，LRU。</li><li>flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</li><li>size： 最多缓存对象的个数。</li><li>readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li><li>blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li></ul><p>cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace=&quot;mapper.StudentMapper&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="二级缓存实验"><a href="#二级缓存实验" class="headerlink" title="二级缓存实验"></a>二级缓存实验</h4><p>接下来我们通过实验，了解MyBatis二级缓存在使用上的一些特点。<br>在本实验中，id为1的学生名称初始化为点点。</p><h5 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h5><p>测试二级缓存效果，不提交事务，sqlSession1查询完数据后，sqlSession2相同的查询是否会从缓存中获取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCacheWithoutCommitOrClose() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(true); </span><br><span class="line"></span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentById(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-34-04.jpg" alt="img"><br>我们可以看到，当sqlsession没有调用commit()方法时，二级缓存并没有起到作用。</p><h5 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h5><p>测试二级缓存效果，当提交事务时，sqlSession1查询完数据后，sqlSession2相同的查询是否会从缓存中获取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCacheWithCommitOrClose() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(true); </span><br><span class="line"></span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        sqlSession1.commit();</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentById(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-34-25.jpg" alt="img"><br>从图上可知，sqlsession2的查询，使用了缓存，缓存的命中率是0.5。</p><h5 id="实验3-1"><a href="#实验3-1" class="headerlink" title="实验3"></a>实验3</h5><p>测试update操作是否会刷新该namespace下的二级缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCacheWithUpdate() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession3 = factory.openSession(true); </span><br><span class="line"></span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentById(1));</span><br><span class="line">        sqlSession1.commit();</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentById(1));</span><br><span class="line"></span><br><span class="line">        studentMapper3.updateStudentName(&quot;方方&quot;,1);</span><br><span class="line">        sqlSession3.commit();</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentById(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-34-48.jpg" alt="img"><br>我们可以看到，在sqlSession3更新数据库，并提交事务后，sqlsession2的StudentMapper namespace下的查询走了数据库，没有走Cache。</p><h5 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h5><p>验证MyBatis的二级缓存不适应用于映射文件中存在多表查询的情况。<br>通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于namespace的，多表查询语句所在的namspace无法感应到其他namespace中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCacheWithDiffererntNamespace() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession1 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession2 = factory.openSession(true); </span><br><span class="line">        SqlSession sqlSession3 = factory.openSession(true); </span><br><span class="line"></span><br><span class="line">        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">        ClassMapper classMapper = sqlSession3.getMapper(ClassMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;studentMapper读取数据: &quot; + studentMapper.getStudentByIdWithClassInfo(1));</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentByIdWithClassInfo(1));</span><br><span class="line"></span><br><span class="line">        classMapper.updateClassName(&quot;特色一班&quot;,1);</span><br><span class="line">        sqlSession3.commit();</span><br><span class="line">        System.out.println(&quot;studentMapper2读取数据: &quot; + studentMapper2.getStudentByIdWithClassInfo(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-35-29.jpg" alt="img"><br>在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在StudentMapper中增加了一个查询方法getStudentByIdWithClassInfo，用于查询学生所在的班级，涉及到多表查询。在ClassMapper中添加了updateClassName，根据班级id更新班级名的操作。<br>当sqlsession1的studentmapper查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当sqlSession3的classMapper的updateClassName方法对class表进行更新时，updateClassName不属于StudentMapper的namespace，所以StudentMapper下的cache没有感应到变化，没有刷新缓存。当StudentMapper中同样的查询再次发起时，从缓存中读取了脏数据。</p><h5 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h5><p>为了解决实验4的问题呢，可以使用Cache ref，让ClassMapper引用StudenMapper命名空间，这样两个映射文件对应的Sql操作都使用的是同一块缓存了。<br>执行结果：<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-35-45.jpg" alt="img"><br>不过这样做的后果是，缓存的粒度变粗了，多个Mapper namespace下的所有操作都会对缓存使用造成影响。</p><h4 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h4><p>MyBatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用CachingExecutor装饰了BaseExecutor的子类，在委托具体职责给delegate之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示。<br><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-23-16-57-08.jpg" alt="img"></p><h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>源码分析从CachingExecutor的query方法展开，源代码走读过程中涉及到的知识点较多，不能一一详细讲解，读者朋友可以自行查询相关资料来学习。<br>CachingExecutor的query方法，首先会从MappedStatement中获得在配置初始化时赋予的Cache。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = ms.getCache();</span><br></pre></td></tr></table></figure><p>本质上是装饰器模式的使用，具体的装饰链是</p><blockquote><p>SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。</p></blockquote><p><img src="https://tech.meituan.com/img/mybatis-cache/2017-11-15-16-36-08.jpg" alt="img"></p><p>以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。</p><ul><li>SynchronizedCache： 同步Cache，实现比较简单，直接使用synchronized修饰方法。</li><li>LoggingCache： 日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。</li><li>SerializedCache： 序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li><li>LruCache： 采用了Lru算法的Cache实现，移除最近最少使用的key/value。</li><li>PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li></ul><p>然后是判断是否需要刷新缓存，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure><p>在默认的设置中SELECT语句不会刷新缓存，insert/update/delte会刷新缓存。进入该方法。代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis的CachingExecutor持有了TransactionalCacheManager，即上述代码中的tcm。<br>TransactionalCacheManager中持有了一个Map，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;();</span><br></pre></td></tr></table></figure><p>这个Map保存了Cache和用TransactionalCache包装后的Cache的映射关系。<br>TransactionalCache实现了Cache接口，CachingExecutor会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。<br>在TransactionalCache的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    clearOnCommit = true;</span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachingExecutor继续往下走，ensureNoOutParams主要是用来处理存储过程的，暂时不用考虑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</span><br><span class="line">    ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure><p>之后会尝试从tcm中获取缓存的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure><p>在getObject方法中，会把获取值的职责一路传递，最终到PerpetualCache。如果没有查到，会把key加入Miss集合，这个主要是为了统计命中率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object object = delegate.getObject(key);</span><br><span class="line">if (object == null) &#123;</span><br><span class="line">    entriesMissedInCache.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachingExecutor继续往下走，如果查询到数据，则调用tcm.putObject方法，往缓存中放入值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (list == null) &#123;</span><br><span class="line">    list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    tcm.putObject(cache, key, list); // issue #578 and #116</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcm的put方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void putObject(Object key, Object object) &#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的代码分析中，我们可以明白，如果不调用commit方法的话，由于TranscationalCache的作用，并不会对二级缓存造成直接的影响。因此我们看看Sqlsession的commit方法中做了什么。代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void commit(boolean force) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br></pre></td></tr></table></figure><p>因为我们使用了CachingExecutor，首先会进入CachingExecutor实现的commit方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void commit(boolean required) throws SQLException &#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会把具体commit的职责委托给包装的Executor。主要是看下tcm.commit()，tcm最终又会调用到TrancationalCache。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里的clearOnCommit就想起刚才TrancationalCache的clear方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入flushPendingEntries方法。代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void flushPendingEntries() &#123;</span><br><span class="line">    for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    ................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在flushPendingEntries中，将待提交的Map进行循环处理，委托给包装的Cache类，进行putObject的操作。<br>后续的查询操作会重复执行这套流程。如果是insert|update|delete的话，会统一进入CachingExecutor的update方法，其中调用了这个函数，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void flushCacheIfRequired(MappedStatement ms)</span><br></pre></td></tr></table></figure><p>在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再赘述。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li><li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis,Memcached等分布式缓存可能成本更低，安全性也更高。</li></ol><h3 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h3><p>本文对介绍了MyBatis一二级缓存的基本概念，并从应用及源码的角度对MyBatis的缓存机制进行了分析。最后对MyBatis缓存机制做了一定的总结，个人建议MyBatis缓存特性在生产环境中进行关闭，单纯作为一个ORM框架使用可能更为合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;MyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。个人在业务开发中也处理过一些由于MyBatis缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理MyBatis缓存机制。&lt;br&gt;本次分析中涉及到的代码和数据库表均放在GitHub上，地址： &lt;a href=&quot;https://github.com/kailuncen/mybatis-cache-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mybatis-cache-demo&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;本文按照以下顺序展开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一级缓存介绍及相关配置。&lt;/li&gt;
&lt;li&gt;一级缓存工作流程及源码分析。&lt;/li&gt;
&lt;li&gt;一级缓存总结。&lt;/li&gt;
&lt;li&gt;二级缓存介绍及相关配置。&lt;/li&gt;
&lt;li&gt;二级缓存源码分析。&lt;/li&gt;
&lt;li&gt;二级缓存总结。&lt;/li&gt;
&lt;li&gt;全文总结。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="https://masonnpe.github.io/categories/Mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>volatile实现原理</title>
    <link href="https://masonnpe.github.io/2018/11/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://masonnpe.github.io/2018/11/25/并发编程/volatile实现原理/</id>
    <published>2018-11-25T09:55:12.444Z</published>
    <updated>2018-11-25T09:55:44.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在对被<code>volatile</code>修饰的共享变量进行写操作时，会多出<code>Lock</code>前缀的指令。作用是：</p><ol><li>将当前处理器缓存行的数据写回到系统内存；</li><li>使得其他CPU里缓存了该内存地址的数据无效；</li><li>当处理器发现本地缓存失效后，就会从内存中重新读取该变量数据。</li></ol><p>通过这样的机制就使得每个线程都能获得该变量的最新值，从而避免出现数据脏读的现象。</p><blockquote><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，操作完成后不知道何时将数据写回到内存。如果对声明了<code>volatile</code>的变量进行写操作，虚拟机就会向处理器发送一条<code>Lock</code>前缀的指令，将这个变量所在缓存行的数据写回到系统内存。在多处理器下为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议（每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期），当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p></blockquote><a id="more"></a><h2 id="volatile与重排序"><a href="#volatile与重排序" class="headerlink" title="volatile与重排序"></a>volatile与重排序</h2><p>为了实现<code>volatile</code>的内存语义，JMM会通过插入内存屏障指令来限制特定类型的编译器和处理器重排序</p><ul><li>在每个<code>volatile</code>读后面插入一个LoadLoad屏障：禁止下面所有的普通读操作和上面的<code>volatile</code>读重排序</li><li>在每个<code>volatile</code>读后面插入一个LoadStore屏障：禁止下面所有的普通写操作和上面的<code>volatile</code>读重排序</li><li>在每个<code>volatile</code>写前面插入一个StoreStore屏障：禁止上面的普通写和下面的<code>volatile</code>写重排序</li><li>在每个<code>volatile</code>写后面插入一个StoreLoad屏障：防止上面的<code>volatile</code>写与下面可能有的<code>volatile</code>读/写重排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;在对被&lt;code&gt;volatile&lt;/code&gt;修饰的共享变量进行写操作时，会多出&lt;code&gt;Lock&lt;/code&gt;前缀的指令。作用是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将当前处理器缓存行的数据写回到系统内存；&lt;/li&gt;
&lt;li&gt;使得其他CPU里缓存了该内存地址的数据无效；&lt;/li&gt;
&lt;li&gt;当处理器发现本地缓存失效后，就会从内存中重新读取该变量数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这样的机制就使得每个线程都能获得该变量的最新值，从而避免出现数据脏读的现象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，操作完成后不知道何时将数据写回到内存。如果对声明了&lt;code&gt;volatile&lt;/code&gt;的变量进行写操作，虚拟机就会向处理器发送一条&lt;code&gt;Lock&lt;/code&gt;前缀的指令，将这个变量所在缓存行的数据写回到系统内存。在多处理器下为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议（每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期），当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://masonnpe.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="volatile" scheme="https://masonnpe.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的工作原理及代码实现</title>
    <link href="https://masonnpe.github.io/2018/11/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://masonnpe.github.io/2018/11/12/并发编程/ConcurrentHashMap的工作原理及代码实现/</id>
    <published>2018-11-11T16:36:28.196Z</published>
    <updated>2018-11-25T15:22:18.373Z</updated>
    
    <content type="html"><![CDATA[<p>1.8以后的锁的颗粒度，是加在链表头上的，这个是个思路上的突破。</p><h2 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap"></a>为什么需要ConcurrentHashMap</h2><p>Hashtable本身比较低效，因为它的实现基本就是将put、get、size等各种方法加上synchronized。这就导致了所有并发操作都要竞争同一把锁，大大降低了并发操作的效率。<br>HashMap不是线程安全的，并发情况会导致类似CPU占用100%等一些问题。Collections提供的同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为synchronized方法，但是还是利用了“this”作为互斥的mutex，没有真正意义上的改进！<br>所以Hashtable或者同步包装版本，都只是适合在非高度并发的场景下。</p><a id="more"></a><h2 id="ConcurrentHashMap分析"><a href="#ConcurrentHashMap分析" class="headerlink" title="ConcurrentHashMap分析"></a>ConcurrentHashMap分析</h2><p>早期ConcurrentHashMap，其实现是基于分段锁，也就是将内部进行分段（Segment），里面则是HashEntry的数组，和HashMap类似，哈希相同的条目也是以链表形式存放。HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，去直接完成部分操作，以最优化性能，毕竟Unsafe中的很多操作都是JVM intrinsic优化过的。核心是利用分段设计，在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似Hashtable整体同步的问题，大大提高了性能。<br>对于put操作，首先是通过二次哈希避免哈希冲突，然后以Unsafe调用方式，直接获取相应的Segment，然后进行线程安全的put操作：<br>所以，从上面的源码清晰的看出，在进行并发写操作时：<br>ConcurrentHashMap会获取冲入锁，以保证数据一致性，Segment本身就是基于ReentrantLock的扩展实现，所以，在并发修改期间，相应Segment是被锁定的。<br>如果不进行同步，简单的计算所有Segment的总值，可能会因为并发put，导致结果不准确，但是直接锁定所有Segment进行计算，就会变得非常昂贵。其实，分离锁也限制了Map的初始化等操作。<br>所以，ConcurrentHashMap的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数2），来试图获得可靠值。如果没有监控到发生变化（通过对比Segment.modCount），就直接返回，否则获取锁进行操作。<br>下面我来对比一下，在Java 8中ConcurrentHashMap<br>数据存储利用volatile来保证可见性。<br>使用CAS等操作，在特定场景进行无锁并发操作。<br>使用Unsafe、LongAdder之类底层手段，进行极端情况的优化。<br>先看看现在的数据存储内部实现，我们可以发现Key是fnal的，因为在生命周期中，一个条目的Key发生变化是不可能的；与此同时val，则声明为volatile，以保证可见性。<br>直接看并发的put是如何实现的。<br>fnal V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException();<br>int hash = spread(key.hashCode());<br>int binCount = 0;<br>for (Node[] tab = table;;) {<br>Node f; int n, i, fh; K fk; V fv;<br>if (tab == null || (n = tab.length) == 0)<br>tab = initTable();<br>else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {<br>// 利用CAS去进行无锁线程安全操作，如果bin是空的<br>if (casTabAt(tab, i, null, new Node(hash, key, value)))<br>break;<br>}<br>else if ((fh = f.hash) == MOVED)<br>tab = helpTransfer(tab, f);<br>else if (onlyIfAbsent // 不加锁，进行检查<br>&amp;&amp; fh == hash<br>&amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))<br>&amp;&amp; (fv = f.val) != null)<br>return fv;<br>else {<br>V oldVal = null;<br>synchronized (f) {<br>// 细粒度的同步修改操作…<br>}<br>}<br>// Bin超过阈值，进行树化<br>if (binCount != 0) {<br>if (binCount &gt;= TREEIFY_THRESHOLD)<br>treeifyBin(tab, i);<br>if (oldVal != null)<br>return oldVal;<br>break;<br>}<br>}<br>}<br>addCount(1L, binCount);<br>return null;<br>}<br>初始化操作实现在initTable里面，这是一个典型的CAS使用场景，利用volatile的sizeCtl作为互斥手段：如果发现竞争性的初始化，就spin在那里，等待条件恢复；否则利用CAS设<br>置排他标志。如果成功则进行初始化；否则重试。<br>请参考下面代码：<br>private fnal Node[] initTable() {<br>Node[] tab; int sc;<br>while ((tab = table) == null || tab.length == 0) {<br>// 如果发现冲突，进行spin等待<br>if ((sc = sizeCtl) &lt; 0)<br>Thread.yield();<br>// CAS成功返回true，则进入真正的初始化逻辑<br>else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {<br>try {<br>if ((tab = table) == null || tab.length == 0) {<br>int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;<br>@SuppressWarnings(“unchecked”)<br>Node[] nt = (Node[])new Node[n];<br>table = tab = nt;<br>sc = n - (n &gt;&gt;&gt; 2);<br>}<br>} fnally {<br>sizeCtl = sc;<br>}<br>break;<br>}<br>}<br>return tab;<br>}<br>当bin为空时，同样是没有必要锁定，也是以CAS操作去放置。<br>你有没有注意到，在同步逻辑上，它使用的是synchronized，而不是通常建议的ReentrantLock之类，这是为什么呢？现代JDK中，synchronized已经被不断优化，可以不再过分<br>极客时间<br>担心性能差异，另外，相比于ReentrantLock，它可以减少内存消耗，这是个非常大的优势。<br>与此同时，更多细节实现通过使用Unsafe进行了优化，例如tabAt就是直接利用getObjectAcquire，避免间接调用的开销。<br>satic fnal  Node tabAt(Node[] tab, int i) {<br>return (Node)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);<br>}<br>再看看，现在是如何实现size操作的。阅读代码你会发现，真正的逻辑是在sumCount方法中， 那么sumCount做了什么呢？<br>fnal long sumCount() {<br>CounterCell[] as = counterCells; CounterCell a;<br>long sum = baseCount;<br>if (as != null) {<br>for (int i = 0; i &lt; as.length; ++i) {<br>if ((a = as[i]) != null)<br>sum += a.value;<br>}<br>}<br>return sum;<br>}<br>我们发现，虽然思路仍然和以前类似，都是分而治之的进行计数，然后求和处理，但实现却基于一个奇怪的CounterCell。 难道它的数值，就更加准确吗？数据一致性是怎么保证<br>的？<br>satic fnal class CounterCell {<br>volatile long value;<br>CounterCell(long x) { value = x; }<br>}<br>其实，对于CounterCell的操作，是基于java.util.concurrent.atomic.LongAdder进行的，是一种JVM利用空间换取更高效率的方法，利用了Striped64内部的复杂逻辑。这个东<br>西非常小众，大多数情况下，建议还是使用AtomicLong，足以满足绝大部分应用的性能需求。<br>今天我从线程安全问题开始，概念性的总结了基本容器工具，分析了早期同步容器的问题，进而分析了Java 7和Java 8中ConcurrentHashMap是如何设计实现的，希<br>望ConcurrentHashMap的并发技巧对你在日常开发可以有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.8以后的锁的颗粒度，是加在链表头上的，这个是个思路上的突破。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#为什么需要ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;为什么需要ConcurrentHashMap&quot;&gt;&lt;/a&gt;为什么需要ConcurrentHashMap&lt;/h2&gt;&lt;p&gt;Hashtable本身比较低效，因为它的实现基本就是将put、get、size等各种方法加上synchronized。这就导致了所有并发操作都要竞争同一把锁，大大降低了并发操作的效率。&lt;br&gt;HashMap不是线程安全的，并发情况会导致类似CPU占用100%等一些问题。Collections提供的同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为synchronized方法，但是还是利用了“this”作为互斥的mutex，没有真正意义上的改进！&lt;br&gt;所以Hashtable或者同步包装版本，都只是适合在非高度并发的场景下。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://masonnpe.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ConcurrentHashMap" scheme="https://masonnpe.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Docker与Java</title>
    <link href="https://masonnpe.github.io/2018/11/12/Docker/Docker%E4%B8%8EJava/"/>
    <id>https://masonnpe.github.io/2018/11/12/Docker/Docker与Java/</id>
    <published>2018-11-11T16:25:30.725Z</published>
    <updated>2018-11-25T15:23:22.241Z</updated>
    
    <content type="html"><![CDATA[<p>对于Java来说，Docker毕竟是一个较新的环境，例如，其内存、CPU等资源限制是通过CGroup（Control Group）实现的，早期的JDK版本（8u131之前）并不能识别这些限<br>制，进而会导致一些基础问题：<br>如果未配置合适的JVM堆和元数据区、直接内存等参数，Java就有可能试图使用超过容器限制的内存，最终被容器OOM kill，或者自身发生OOM。<br>错误判断了可获取的CPU资源，例如，Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程数等。<br>从应用打包、发布等角度出发，JDK自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。<br>如果考虑到微服务、Serverless等新的架构和场景，Java自身的大小、内存占用、启动速度，都存在一定局限性，因为Java早期的优化大多是针对长时间运行的大型服务器端应<br>用。<br>Java在容器环境的局限性来源，Docker到底有什么特别？<br>虽然看起来Docker之类容器和虚拟机非常相似，例如，它也有自己的shell，能独立安装软件包，运行时与其他容器互不干扰。但是，如果深入分析你会发现，Docker并不是一种完<br>全的虚拟化技术，而更是一种轻量级的隔离技术。<br><a id="more"></a></p><p>从技术角度，基于namespace，Docker为每个容器提供了单独的命名空间，对网络、PID、用户、IPC通信、文件系统挂载点等实<br>现了隔离。对于CPU、内存、磁盘IO等计算资源，则是通过CGroup进行管理。<br>Docker仅在类似Linux内核之上实现了有限的隔离和虚拟化，并不是像传统虚拟化软件那样，独立运行一个新的操作系统。如果是虚拟化的操作系统，不管是Java还是其他程序，只要调用的是同一个系统API，都可以透明地获取所需的信息，基本不需要额外的兼容性改变。容器虽然省略了虚拟操作系统的开销，实现了轻量级的目标，但也带来了额外复杂性，它限制对于应用不是透明的，需要用户理解Docker的新行为。<br>第一，容器环境对于计算资源的管理方式是全新的，CGroup作为相对比较新的技术，历史版本的Java显然并不能自然地理解相应的资源限制。<br>第二，namespace对于容器内的应用细节增加了一些微妙的差异，比如jcmd、jstack等工具会依赖于“/proc//”下面提供的部分信息，但是Docker的设计改变了这部分信息的原有<br>结构，我们需要对原有工具进行修改以适应这种变化。<br>从JVM运行机制的角度，为什么这些“沟通障碍”会导致OOM等问题呢？<br>你可以思考一下，这个问题实际是反映了JVM如何根据系统资源（内存、CPU等）情况，在启动时设置默认参数。<br>这就是所谓的Ergonomics机制，例如：<br>JVM会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的1/64；并将堆最大值，设置为系统内存的1/4。<br>而JVM检测到系统的CPU核数，则直接影响到了Parallel GC的并行线程数目和JIT complier线程数目，甚至是我们应用中ForkJoinPool等机制的并行等级。<br>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房<br>间是给我住的。<br>更加严重的是，JVM的一些原有诊断或备用机制也会受到影响。为保证服务的可用性，一种常见的选择是依赖“-XX:OnOutOfMemoryError”功能，通过调用处理脚本的形式来做一<br>些补救措施，比如自动重启服务等。但是，这种机制是基于fork实现的，当Java进程已经过度提交内存时，fork新的进程往往已经不可能正常运行了。<br>根据前面的总结，似乎问题非常棘手，那我们在实践中，如何解决这些问题呢？<br>首先，如果你能够升级到最新的JDK版本，这个问题就迎刃而解了。<br>针对这种情况，JDK 9中引入了一些实验性的参数，以方便Docker和Java“沟通”，例如针对内存限制，可以使用下面的参数设置：<br>-XX:+UnlockExperimentalVMOptions<br>-XX:+UseCGroupMemoryLimitForHeap<br>注意，这两个参数是顺序敏感的，并且只支持Linux环境。而对于CPU核心数限定，Java已经被修正为可以正确理解“–cpuset-cpus”等设置，无需单独设置参数。<br>如果你可以切换到JDK 10或者更新的版本，问题就更加简单了。Java对容器（Docker）的支持已经比较完善，默认就会自适应各种资源限制和实现差异。前面提到的实验性参<br>数“UseCGroupMemoryLimitForHeap”已经被标记为废弃。<br>与此同时，新增了参数用以明确指定CPU核心的数目。<br>-XX:ActiveProcessorCount=N<br>如果实践中发现有问题，也可以使用“-XX:-UseContainerSupport”，关闭Java的容器支持特性，这可以作为一种防御性机制，避免新特性破坏原有基础功能。当然，也欢迎你<br>向OpenJDK社区反馈问题。<br>幸运的是，JDK 9中的实验性改进已经被移植到Oracle JDK 8u131之中，你可以直接下载相应镜像，并配置“UseCGroupMemoryLimitForHeap”，后续很有可能还会进一步<br>将JDK 10中相关的增强，应用到JDK 8最新的更新中。<br>但是，如果我暂时只能使用老版本的JDK怎么办？<br>我这里有几个建议：<br>明确设置堆、元数据区等内存区域大小，保证Java进程的总大小可控。<br>例如，我们可能在环境中，这样限制容器内存：<br>$ docker run -it –rm –name yourcontainer -p 8080:8080 -m 800M repo/your-java-container:openjdk<br>极客时间<br>那么，就可以额外配置下面的环境变量，直接指定JVM堆大小。<br>-e JAVA_OPTIONS=’-Xmx300m’<br>明确配置GC和JIT并行线程数目，以避免二者占用过多计算资源。<br>-XX:ParallelGCThreads<br>-XX:CICompilerCount<br>除了我前面介绍的OOM等问题，在很多场景中还发现Java在Docker环境中，似乎会意外使用Swap。具体原因待查，但很有可能也是因为Ergonomics机制失效导致的，我建议配<br>置下面参数，明确告知JVM系统内存限额。<br>-XX:MaxRAM=<code>cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code><br>也可以指定Docker运行参数，例如：<br>–memory-swappiness=0<br>这是受操作系统Swappiness机制影响，当内存消耗达到一定门限，操作系统会试图将不活跃的进程换出（Swap out），上面的参数有显式关闭Swap的作用。所以可以看<br>到，Java在Docker中的使用，从操作系统、内核到JVM自身机制，需要综合运用我们所掌握的知识。<br>回顾我在专栏第25讲JVM内存区域的介绍，JVM内存消耗远不止包括堆，很多时候仅仅设置Xmx是不够的，MaxRAM也有助于JVM合理分配其他内存区域。如果应用需要设置更<br>多Java启动参数，但又不确定什么数值合理，可以试试一些社区提供的工具，但要注意通用工具的局限性。<br>更进一步来说，对于容器镜像大小的问题，如果你使用的是JDK 9以后的版本，完全可以使用jlink工具定制最小依赖的Java运行环境，将JDK裁剪为几十M的大小，这样运行起来并<br>不困难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Java来说，Docker毕竟是一个较新的环境，例如，其内存、CPU等资源限制是通过CGroup（Control Group）实现的，早期的JDK版本（8u131之前）并不能识别这些限&lt;br&gt;制，进而会导致一些基础问题：&lt;br&gt;如果未配置合适的JVM堆和元数据区、直接内存等参数，Java就有可能试图使用超过容器限制的内存，最终被容器OOM kill，或者自身发生OOM。&lt;br&gt;错误判断了可获取的CPU资源，例如，Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程数等。&lt;br&gt;从应用打包、发布等角度出发，JDK自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。&lt;br&gt;如果考虑到微服务、Serverless等新的架构和场景，Java自身的大小、内存占用、启动速度，都存在一定局限性，因为Java早期的优化大多是针对长时间运行的大型服务器端应&lt;br&gt;用。&lt;br&gt;Java在容器环境的局限性来源，Docker到底有什么特别？&lt;br&gt;虽然看起来Docker之类容器和虚拟机非常相似，例如，它也有自己的shell，能独立安装软件包，运行时与其他容器互不干扰。但是，如果深入分析你会发现，Docker并不是一种完&lt;br&gt;全的虚拟化技术，而更是一种轻量级的隔离技术。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://masonnpe.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://masonnpe.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID</title>
    <link href="https://masonnpe.github.io/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>https://masonnpe.github.io/2018/11/12/分布式/分布式ID/</id>
    <published>2018-11-11T16:16:42.188Z</published>
    <updated>2018-11-11T16:18:04.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Snowflake &#123;</span><br><span class="line"></span><br><span class="line">  public static final int NODE_SHIFT = 10;</span><br><span class="line">  public static final int SEQ_SHIFT = 12;</span><br><span class="line"></span><br><span class="line">  public static final short MAX_NODE = 1024;</span><br><span class="line">  public static final short MAX_SEQUENCE = 4096;</span><br><span class="line"></span><br><span class="line">  private short sequence;</span><br><span class="line">  private long referenceTime;</span><br><span class="line"></span><br><span class="line">  private int node;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A snowflake is designed to operate as a singleton instance within the context of a node.</span><br><span class="line">   * If you deploy different nodes, supplying a unique node id will guarantee the uniqueness</span><br><span class="line">   * of ids generated concurrently on different nodes.</span><br><span class="line">   *</span><br><span class="line">   * @param node This is an id you use to differentiate different nodes.</span><br><span class="line">   */</span><br><span class="line">  public Snowflake(int node) &#123;</span><br><span class="line">    if (node &lt; 0 || node &gt; MAX_NODE) &#123;</span><br><span class="line">      throw new IllegalArgumentException(String.format(&quot;node must be between %s and %s&quot;, 0, MAX_NODE));</span><br><span class="line">    &#125;</span><br><span class="line">    this.node = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Generates a k-ordered unique 64-bit integer. Subsequent invocations of this method will produce</span><br><span class="line">   * increasing integer values.</span><br><span class="line">   *</span><br><span class="line">   * @return The next 64-bit integer.</span><br><span class="line">   */</span><br><span class="line">  public long next() &#123;</span><br><span class="line"></span><br><span class="line">    long currentTime = System.currentTimeMillis();</span><br><span class="line">    long counter;</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line"></span><br><span class="line">      if (currentTime &lt; referenceTime) &#123;</span><br><span class="line">        throw new RuntimeException(String.format(&quot;Last referenceTime %s is after reference time %s&quot;, referenceTime, currentTime));</span><br><span class="line">      &#125; else if (currentTime &gt; referenceTime) &#123;</span><br><span class="line">        this.sequence = 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.sequence &lt; Snowflake.MAX_SEQUENCE) &#123;</span><br><span class="line">          this.sequence++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Sequence exhausted at &quot; + this.sequence);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      counter = this.sequence;</span><br><span class="line">      referenceTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentTime &lt;&lt; NODE_SHIFT &lt;&lt; SEQ_SHIFT | node &lt;&lt; SEQ_SHIFT | counter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int node = 1;</span><br><span class="line">Snowflake s = new Snowflake(node);</span><br><span class="line">long id = s.next();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;雪花算法&quot;&gt;&lt;a href=&quot;#雪花算法&quot; class=&quot;headerlink&quot; title=&quot;雪花算法&quot;&gt;&lt;/a&gt;雪花算法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="分布式" scheme="https://masonnpe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式ID" scheme="https://masonnpe.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    
  </entry>
  
  <entry>
    <title>ES基本用法</title>
    <link href="https://masonnpe.github.io/2018/11/12/Elasticsearch/ES%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://masonnpe.github.io/2018/11/12/Elasticsearch/ES基本用法/</id>
    <published>2018-11-11T16:15:54.949Z</published>
    <updated>2018-12-14T13:33:19.450Z</updated>
    
    <content type="html"><![CDATA[<p>document  数据 需要有唯一key</p><p>index    表  具有相同字段的docment组成</p><p>node  es实例</p><p>cluster 集群</p><p>_source 原始json数据</p><p>restful api</p><p>倒排索引</p><p> 单词词典  记录所有单词</p><p>倒排列表  在文档中的位置 偏移量offset</p><h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><p>character filters  去p标签  字符替换</p><p>tokenizer 切分 成单词</p><p>token filters  转小写  删除the   of   的 这 那  这种没实际意义的词</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>:<span class="string">"standard"</span>,</span><br><span class="line">  <span class="attr">"filter"</span>: [<span class="string">"lowercase"</span>], </span><br><span class="line">  <span class="attr">"text"</span>:<span class="string">"HeLLo wORld!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">"hello"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">"world"</span>,</span><br><span class="line">      <span class="attr">"start_offset"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"end_offset"</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">      <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自带分词器</p><p>standard 默认分词器  </p><p>simple   非字母字符切分（空格 -之类的）  小写处理</p><p>whitespace   空格切分</p><p>stop    删除语气词  the  of</p><p>keyword  不做分词  </p><p>pattern  正则表达式自定义   默认\w+,非字符做分割</p><p>language  不同语言的分词</p><p>中文分词 IK   jieba  </p><p>基于自然语言  模型 算法  hanpl thulac</p><h4 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_analyzer"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>:<span class="string">"custom"</span>,</span><br><span class="line">          <span class="attr">"tokenizer"</span>:<span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"char_filter"</span>: [<span class="string">"html_strip"</span>],</span><br><span class="line">          <span class="attr">"filter"</span>:[<span class="string">"lowercase"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span>:<span class="string">"my_analyzer"</span>,</span><br><span class="line">  <span class="attr">"text"</span>:<span class="string">"HeLLo wORld!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义mapping</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>:&#123;</span><br><span class="line">      <span class="attr">"dynamic"</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"name"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"keyword"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"age"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"integer"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"mason"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"mason good"</span>,</span><br><span class="line">  <span class="attr">"money"</span>:<span class="number">3123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_all 所有字段匹配</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"_all"</span>: <span class="string">"mason"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"index": false 不会被查询</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>:&#123;</span><br><span class="line">      <span class="attr">"dynamic"</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">          <span class="attr">"index"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;document  数据 需要有唯一key&lt;/p&gt;
&lt;p&gt;index    表  具有相同字段的docment组成&lt;/p&gt;
&lt;p&gt;node  es实例&lt;/p&gt;
&lt;p&gt;cluster 集群&lt;/p&gt;
&lt;p&gt;_source 原始json数据&lt;/p&gt;
&lt;p&gt;restful api&lt;
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://masonnpe.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://masonnpe.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon</title>
    <link href="https://masonnpe.github.io/2018/11/12/SpringCloud/Ribbon/"/>
    <id>https://masonnpe.github.io/2018/11/12/SpringCloud/Ribbon/</id>
    <published>2018-11-11T16:10:48.092Z</published>
    <updated>2018-12-14T13:38:56.457Z</updated>
    
    <content type="html"><![CDATA[<p>ribbon是一个基于http和tcp的客户端负载均衡工具</p><p>eureka强调了cap中的ap    zookeeper强调 cp</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ribbon是一个基于http和tcp的客户端负载均衡工具&lt;/p&gt;
&lt;p&gt;eureka强调了cap中的ap    zookeeper强调 cp&lt;/p&gt;

      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://masonnpe.github.io/categories/SpringCloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix</title>
    <link href="https://masonnpe.github.io/2018/11/12/SpringCloud/Hystrix/"/>
    <id>https://masonnpe.github.io/2018/11/12/SpringCloud/Hystrix/</id>
    <published>2018-11-11T16:10:26.188Z</published>
    <updated>2018-12-14T13:38:42.671Z</updated>
    
    <content type="html"><![CDATA[<p>因为网络问题或者服务自身问题出现调用故障或延迟，会直接导致调用方的堆外服务也出现延迟，请求不断鞥家，调用方等待响应形成任务挤压，导致自身服务瘫痪。为了解决连锁故障，要使用断路器服务保护机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为网络问题或者服务自身问题出现调用故障或延迟，会直接导致调用方的堆外服务也出现延迟，请求不断鞥家，调用方等待响应形成任务挤压，导致自身服务瘫痪。为了解决连锁故障，要使用断路器服务保护机制&lt;/p&gt;

      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://masonnpe.github.io/categories/SpringCloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka</title>
    <link href="https://masonnpe.github.io/2018/11/12/SpringCloud/Eureka/"/>
    <id>https://masonnpe.github.io/2018/11/12/SpringCloud/Eureka/</id>
    <published>2018-11-11T16:09:42.006Z</published>
    <updated>2018-12-14T13:38:27.652Z</updated>
    
    <content type="html"><![CDATA[<p>当ribbon与eureka联合使用时ribbon的服务配置清单ribbonserverlist会被discoveryEnabledNIWSServerlist重写，扩展成从eureka注册中心获取服务端列表</p><p>服务治理机制 注册中心互相注册组成高可用集群</p><p>失效剔除   eureka会创建一个定时任务，默认每隔一段时间当清单中超时的没有预约的服务剔除</p><p>自我保护  服务再注册是会维护一个心跳连接，eureka会将实例注册信息保存起来,让这些实例不过期，客户端必须要有容错机制，如请求重试，断路器等等</p><p>服务提供者  启动的时候会发送rest请求将自己注册到eureka上，同时带上自身服务的一些元数据，eureka接受到rest请求后，将元数据信息存储再一个双层map，第一层key是服务名，第二层key是具体服务的实例名</p><p>服务同步  服务提供者注册到不同的服务中心，提供者注册时会将请求装发到集群中其他的注册中心，实现同步</p><p>服务续约   注册完服务后，服务提供者会维护一个心跳，防止eureka将服务实例从服务列表中剔除</p><p>服务获取 启动消费者时，发送一个rest请求给注册中心，来获取上面注册的服务清单，eureka每隔一段时间返回给客户端</p><p>服务调用  消费端获取清单后，通过服务名可以获取具体提供服务的实例名和元数据信息，ribbon会默认采用轮询的方式进行调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当ribbon与eureka联合使用时ribbon的服务配置清单ribbonserverlist会被discoveryEnabledNIWSServerlist重写，扩展成从eureka注册中心获取服务端列表&lt;/p&gt;
&lt;p&gt;服务治理机制 注册中心互相注册组成高可用集群&lt;/p
      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://masonnpe.github.io/categories/SpringCloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala集合</title>
    <link href="https://masonnpe.github.io/2018/11/11/Scala/Scala%E9%9B%86%E5%90%88/"/>
    <id>https://masonnpe.github.io/2018/11/11/Scala/Scala集合/</id>
    <published>2018-11-11T15:35:05.506Z</published>
    <updated>2018-11-11T15:36:21.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>new Array<a href=""></a>   </p><p>Array()    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr=new Array[String](5)</span><br><span class="line">arr(1)=&quot;hello&quot;</span><br><span class="line">println(arr.length)</span><br><span class="line">var arr2=Array(&quot;hello&quot;,&quot;world&quot;)</span><br><span class="line">println(arr2.mkString(&quot;-&quot;))</span><br><span class="line">var d=scala.collection.mutable.ArrayBuffer[String]()       //  可变的</span><br><span class="line">d += &quot;a&quot;</span><br><span class="line">d += (&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</span><br><span class="line">d ++= arr                                             // 加其他数组</span><br><span class="line">d.insert(5,&quot;mason&quot;)                                   // 插入指定位置</span><br><span class="line">println(d)</span><br><span class="line">remove</span><br><span class="line">trimend</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Nil=空的list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var l=List(1,23,4,5,67)</span><br><span class="line">println(l.head)        //第一个元素</span><br><span class="line">println(l.tail)        //除了第一个</span><br><span class="line">var l2=1::Nil          //1是头  Nil是尾</span><br><span class="line"></span><br><span class="line">var lb=ListBuffer[Int]()  // 可变list</span><br><span class="line">lb+=(1,23,5,4)</span><br><span class="line">println(lb)</span><br></pre></td></tr></table></figure><p>set</p><p>map</p><p>option</p><p>some</p><p>none</p><p>tuple</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;new Array&lt;a href=&quot;&quot;&gt;&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;Array()    &lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Scala" scheme="https://masonnpe.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://masonnpe.github.io/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>对比HashMap、Hashtable、LinkedHashMap、TreeMap</title>
    <link href="https://masonnpe.github.io/2018/11/11/Java/%E5%AF%B9%E6%AF%94HashMap%E3%80%81Hashtable%E3%80%81LinkedHashMap%E3%80%81TreeMap/"/>
    <id>https://masonnpe.github.io/2018/11/11/Java/对比HashMap、Hashtable、LinkedHashMap、TreeMap/</id>
    <published>2018-11-11T13:48:01.884Z</published>
    <updated>2018-11-11T13:49:46.373Z</updated>
    
    <content type="html"><![CDATA[<p>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。<br>TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口实现排序方式。</p><p>HashMap基于哈希思想实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构</p><p>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍<code>newCap = oldCap &lt;&lt; 1</code></p><p>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致，在并发环境可能出现无限循环占用CPU、size不准确等诡异的问题。可以使用如下方法进行同步</p><ol><li>可以用 Collections的synchronizedMap方法</li><li>使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</li></ol><p>LinkedHashMap通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所<br>谓的put、get、compute等，都算作“访问”。<br>这种行为适用于一些特定应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用LinkedHashMap提供的机制来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class LinkedHashMapSample &#123;</span><br><span class="line"> public satic void main(String[] args) &#123;</span><br><span class="line"> LinkedHashMap&lt;String, String&gt; accessOrderedMap = new LinkedHashMap&lt;&gt;(16, 0.75F, true)&#123;</span><br><span class="line"> @Override</span><br><span class="line"> protected boolean removeEldesEntry(Map.Entry&lt;String, String&gt; eldes) &#123; // 实现自定义删除策略，否则行为就和普遍Map没有区别</span><br><span class="line"> return size() &gt; 3;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> accessOrderedMap.put(&quot;Project1&quot;, &quot;Valhalla&quot;);</span><br><span class="line"> accessOrderedMap.put(&quot;Project2&quot;, &quot;Panama&quot;);</span><br><span class="line"> accessOrderedMap.put(&quot;Project3&quot;, &quot;Loom&quot;);</span><br><span class="line"> accessOrderedMap.forEach( (k,v) -&gt; &#123;</span><br><span class="line"> Sysem.out.println(k +&quot;:&quot; + v);</span><br><span class="line"> &#125;);</span><br><span class="line"> // 模拟访问</span><br><span class="line"> accessOrderedMap.get(&quot;Project2&quot;);</span><br><span class="line"> accessOrderedMap.get(&quot;Project2&quot;);</span><br><span class="line"> accessOrderedMap.get(&quot;Project3&quot;);</span><br><span class="line"> Sysem.out.println(&quot;Iterate over should be not afected:&quot;);</span><br><span class="line"> accessOrderedMap.forEach( (k,v) -&gt; &#123;</span><br><span class="line"> Sysem.out.println(k +&quot;:&quot; + v);</span><br><span class="line"> &#125;);</span><br><span class="line"> // 触发删除</span><br><span class="line"> accessOrderedMap.put(&quot;Project4&quot;, &quot;Mission Control&quot;);</span><br><span class="line"> Sysem.out.println(&quot;Oldes entry should be removed:&quot;);</span><br><span class="line"> accessOrderedMap.forEach( (k,v) -&gt; &#123;// 遍历顺序不变</span><br><span class="line"> Sysem.out.println(k +&quot;:&quot; + v);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据resize源码，不考虑极端情况（容量理论最大极限由MAXIMUM_CAPACITY指定，数值为 1&lt;&lt;30，也就是2的30次方），我们可以归纳为：<br>门限值等于（负载因子）x（容量），如果构建HashMap的时候没有指定它们，那么就是依据相应的默认常量值。<br>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据putVal中的逻辑，当元素个数超过门限大小时，则调整Map大小。<br>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。<br>3.容量、负载因子和树化<br>前面我们快速梳理了一下HashMap从创建到放入键值对的相关逻辑，现在思考一下，为什么我们需要在乎容量和负载因子呢？<br>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不<br>能提供所谓常数时间存的性能。<br>既然容量和负载因子这么重要，我们在实践中应该如何选择呢？<br>如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小。具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合<br>计算条件：<br>极客时间<br>负载因子 * 容量 &gt; 元素数量<br>所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是2的幂数，结论已经非常清晰了。<br>而对于负载因子，我建议：<br>如果没有特别需求，不要轻易进行更改，因为JDK自身的默认负载因子是非常符合通用场景的需求的。<br>如果确实需要调整，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能。<br>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。<br>我们前面提到了树化改造，对应逻辑主要在putVal和treeifyBin中。<br>fnal void treeifyBin(Node[] tab, int hash) {<br>int n, index; Node e;<br>if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>resize();<br>else if ((e = tab[index = (n - 1) &amp; hash]) != null) {<br>//树化改造逻辑<br>}<br>}<br>上面是精简过的treeifyBin示意，综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当bin的数量大于TREEIFY_THRESHOLD时：<br>如果容量小于MIN_TREEIFY_CAPACITY，只会进行简单的扩容。<br>如果容量大于MIN_TREEIFY_CAPACITY ，则会进行树化改造。<br>那么，为什么HashMap要树化呢？<br>本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。<br>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，<br>国内一线互联网公司就发生过类似攻击事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现Comparator 接口时，key 不可以为null；当实现
      
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="HashMap" scheme="https://masonnpe.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>对比Vector、ArrayList、LinkedList有何区别</title>
    <link href="https://masonnpe.github.io/2018/11/11/Java/%E5%AF%B9%E6%AF%94Vector%E3%80%81ArrayList%E3%80%81LinkedList%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB/"/>
    <id>https://masonnpe.github.io/2018/11/11/Java/对比Vector、ArrayList、LinkedList有何区别/</id>
    <published>2018-11-11T13:47:33.533Z</published>
    <updated>2018-11-27T15:23:51.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><code>ArrayList</code> 是基于数组实现的，实现了 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p>数组的默认大小为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>相当于动态数据，其中最重要的两个属性分别是:<br><code>elementData</code> 数组，以及 <code>size</code> 大小。<br>在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，减少扩容操作的次数。更要减少在指定位置插入数据的操作。</p><p>删除元素时需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 ArrayList 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">      <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">      <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">      s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">      s.writeInt(size);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">      <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">          s.writeObject(elementData[i]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">      s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read in capacity</span></span><br><span class="line">      s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">          ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">          Object[] a = elementData;</span><br><span class="line">          <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">              a[i] = s.readObject();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>当对象中自定义了 writeObject 和 readObject 方法时，JVM 会调用这两个自定义方法来实现序列化与反序列化。</p></blockquote><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似,也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li><li>ArrayList 支持随机访问，LinkedList 不支持；</li><li>LinkedList 在任意位置添加删除元素更快。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 是基于数组实现的，实现了 &lt;code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://masonnpe.github.io/categories/Java/"/>
    
    
      <category term="ArrayList" scheme="https://masonnpe.github.io/tags/ArrayList/"/>
    
      <category term="Vector" scheme="https://masonnpe.github.io/tags/Vector/"/>
    
      <category term="LinkedList" scheme="https://masonnpe.github.io/tags/LinkedList/"/>
    
  </entry>
  
</feed>
